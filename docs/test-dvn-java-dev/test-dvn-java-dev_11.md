# 将所有内容整合在一起

“如果你总是做你一直做的事情，那么你将永远得到你一直得到的东西。”

- 阿尔伯特·爱因斯坦

我们经历了大量的理论，然后进行了更多的实践。整个过程就像一辆飞驰的火车，我们几乎没有机会重复所学的知识。没有休息的时间。

好消息是，现在是反思的时候了。我们将总结我们学到的一切，并学习 TDD 的最佳实践。其中一些已经提到，而其他一些将是新的。

本章涵盖的主题包括：

+   TDD 简而言之

+   命名测试的常见约定和良好实践

+   工具

+   下一步

# TDD 简而言之

**红-绿-重构**是 TDD 的支柱，将其包装成一个简短且可重复的循环。简短意味着非常短。每个阶段的时间通常以分钟甚至秒计算。编写测试，看到它失败，编写足够的实现代码使最后一个测试通过，运行所有测试，并进入绿色阶段。一旦编写了最少的代码，以便我们通过测试获得安全性，就是重构代码的时候了，直到它变得像我们希望的那样好。在这个阶段，测试应该始终通过。在重构过程中不能引入新功能或新测试。在如此短的时间内完成所有这些往往是可怕的，或者听起来可能是不可能的。我们希望通过我们一起做的练习，你的技能已经得到了提高，你的信心和速度也得到了提高。

虽然 TDD 中有“测试”一词，但这并不是主要的好处或目标。TDD 首先是一个更好的设计代码的概念。除此之外，我们最终得到的测试应该用于不断检查应用程序是否按预期继续工作。

之前经常提到速度的重要性。虽然我们在 TDD 方面变得更加熟练是其中的一部分，另一个贡献者是测试替身（模拟、存根、间谍等）。有了这些，我们可以消除对数据库、文件系统、第三方服务等外部依赖的需求。

TDD 的其他好处是什么？文档是其中之一。由于代码本身是我们正在处理的应用程序的唯一准确且始终是最新的表示，使用 TDD 编写的规范（同样也是代码）是我们需要更好地理解代码作用时应该首先去查看的地方。

设计呢？你注意到 TDD 产生了更好设计的代码。与事先定义设计不同，使用 TDD 设计往往是在我们从一个规范进展到另一个规范时逐渐出现的。同时，易于测试的代码就是设计良好的代码。测试迫使我们应用一些编码最佳实践。

我们还了解到 TDD 不仅需要在小单元（方法）上进行。它也可以在更高层次上使用，重点是一个可以跨越多个方法、类，甚至应用程序和系统的特性或行为。在这样一个高层次上实践 TDD 的形式之一是**行为驱动开发**（**BDD**）。与 TDD 不同，它是基于开发人员为开发人员进行的单元测试，BDD 可以被组织中的几乎所有人使用。由于它涉及行为，并且是用自然（无处不在的）语言编写的，测试人员、经理、业务代表等都可以参与其创建，并在以后将其用作参考。

我们将遗留代码定义为没有测试的代码。我们面对了遗留代码给我们带来的一些挑战，并学习了一些可以用来使其可测试的技术。

牢记这一切，让我们一起学习 TDD 的最佳实践。

# 最佳实践

编码最佳实践是软件开发社区随着时间发展出的一套非正式规则，可以帮助提高软件的质量。虽然每个应用都需要一定程度的创造力和原创性（毕竟，我们试图构建一些新的或更好的东西），编码实践可以帮助我们避免一些其他人在我们之前遇到的问题。如果你刚开始使用 TDD，应用一些（如果不是全部）由他人生成的最佳实践是一个好主意。

为了更容易分类 TDD 最佳实践，我们将它们分为四类：

+   命名约定

+   流程

+   开发实践

+   工具

正如你将看到的，它们并不都是 TDD 专用的。由于 TDD 的很大一部分包括编写测试，因此以下部分介绍的许多最佳实践适用于一般测试，而其他一些则与一般编码最佳实践相关。无论起源如何，当练习 TDD 时，所有这些都是有用的。

以一定的怀疑态度接受建议。成为一名优秀的程序员不仅仅是知道如何编码，还包括能够决定哪种实践、框架或风格最适合项目和团队。灵活并不是指遵循别人的规则，而是知道如何适应环境并选择最适合团队和项目的最佳工具和实践。

# 命名约定

命名约定有助于更好地组织测试，使开发人员更容易找到他们正在寻找的内容。另一个好处是许多工具期望遵循这些约定。目前有许多使用中的命名约定，这里介绍的只是冰山一角。逻辑是任何命名约定都比没有好。最重要的是团队中的每个人都知道正在使用哪些约定并且对其感到舒适。选择更流行的约定的优势在于，团队的新成员可以快速上手，因为他们可以利用现有知识找到自己的方向。

将实现与测试代码分开。

好处：它避免了意外地将测试与生产二进制文件一起打包；许多构建工具期望测试位于特定的源目录中。

常见做法是至少有两个源目录。实现代码应该位于`src/main/java`，测试代码应该位于`src/test/java`。在更大的项目中，源目录的数量可能会增加，但是实现和测试之间的分离应该保持不变。

像 Gradle 和 Maven 这样的构建工具期望源目录分离以及命名约定。

你可能已经注意到，我们在整本书中使用的`build.gradle`文件并没有明确指定要测试什么，也没有指定要使用哪些类来创建`.jar`文件。Gradle 假定测试位于`src/test/java`，应该打包到 JAR 文件中的实现代码位于`src/main/java`。

将测试类放在与实现相同的包中。

好处：知道测试与代码在同一个包中有助于更快地找到代码。

如前面的做法所述，尽管包是相同的，但类位于不同的源目录中。

本书中的所有练习都遵循了这一惯例。

以与它们测试的类类似的方式命名测试类。

好处：知道测试与它们所测试的类有相似的名称有助于更快地找到类。

一个常用的做法是将测试命名为与实现类相同的名称，后缀为`Test`。例如，如果实现类是`TickTackToe`，测试类应该是`TickTackToeTest`。

然而，在所有情况下，除了我们在重构练习中使用的情况外，我们更喜欢后缀`Spec`。它有助于清晰地区分测试方法主要是作为规定将要开发的内容。测试是这些规范的一个很好的附产品。

为测试方法使用描述性名称。

好处：它有助于理解测试的目标。

在尝试弄清楚为什么某些测试失败或者测试覆盖率应该增加更多测试时，使用描述测试的方法名称是有益的。在测试之前应该清楚地了解设置了什么条件，执行了什么操作，以及预期的结果是什么。

有许多不同的方法来命名测试方法，我们首选的方法是使用 BDD 场景中使用的`Given`/`When`/`Then`语法来命名它们。`Given`描述（前）条件，`When`描述操作，`Then`描述预期结果。如果测试没有前提条件（通常使用`@Before`和`@BeforeClass`注释设置），则可以跳过`Given`。

让我们来看看我们为井字游戏应用程序创建的规范之一：

```java
    @Test 
    public void whenPlayAndWholeHorizontalLineThenWinner() { 
        ticTacToe.play(1, 1); // X 
        ticTacToe.play(1, 2); // O 
        ticTacToe.play(2, 1); // X 
        ticTacToe.play(2, 2); // O 
        String actual = ticTacToe.play(3, 1); // X 
        assertEquals("X is the winner", actual); 
    } 
```

仅通过读取方法的名称，我们就可以理解它是关于什么的。当我们玩游戏并且整个水平或垂直和对角线都被填满时，我们就有了一个赢家。

不要仅依赖注释来提供有关测试目标的信息。当从您喜爱的 IDE 执行测试时，注释不会出现，也不会出现在 CI 或构建工具生成的报告中。

# 流程

TDD 流程是一组核心实践。TDD 的成功实施取决于本节中描述的实践。

在编写实现代码之前编写测试。

好处：它确保编写了可测试的代码；它确保为每一行代码编写了测试。

通过首先编写或修改测试，开发人员在开始编写实现代码之前专注于需求。这与在实现完成后编写测试的方式相比是主要的区别。额外的好处是，通过先编写测试，我们避免了测试作为质量检查（QC）而不是质量保证（QA）的危险。我们试图确保质量内置，而不是稍后检查是否达到了质量目标。

只有在测试失败时才编写新代码。

好处：它确认了测试在没有实现的情况下不起作用。

如果测试通过而无需编写或修改实现代码，那么要么功能已经实现，要么测试有问题。如果确实缺少新功能，那么测试总是通过，因此是无用的。测试应该因为预期的原因而失败。尽管无法保证测试是否验证了正确的事情，但通过首先失败并因为预期的原因，对验证正确性的信心应该很高。

每次实现代码发生变化时重新运行所有测试。

好处：它确保代码更改没有引起意外的副作用。

每当实现代码的任何部分发生变化时，都应该运行所有测试。理想情况下，测试执行速度快，可以由开发人员在本地运行。一旦代码提交到版本控制，应该再次运行所有测试，以确保由于代码合并而没有问题。当有多个开发人员在代码上工作时，这一点尤为重要。应该使用持续集成（CI）工具从存储库中拉取代码，编译它，并运行测试，例如：

+   Jenkins（https://jenkins.io/）

+   Hudson（http://hudson-ci.org/）

+   Travis（https://travis-ci.org/）

+   Bamboo（https://www.atlassian.com/software/bamboo）

在编写新测试之前，所有测试都应该通过。

好处：它保持专注在一个小单位的工作上；实现代码（几乎）总是处于工作状态。

有时候在实际实现之前编写多个测试是很诱人的。在其他情况下，开发人员会忽略现有测试检测到的问题，转向新功能。尽量避免这种情况。在大多数情况下，违反这个规则只会引入技术债务，需要付出更多的利息。TDD 的一个目标是，实现代码（几乎）总是按预期工作的。一些项目由于压力要达到交付日期或保持预算，违反这个规则并且将时间用于新功能，留下修复与失败测试相关的代码的任务。这些项目通常最终会推迟不可避免的事情。

只有在所有测试都通过之后才进行重构。

好处：这种重构是安全的。

如果所有可能受到影响的实现代码都有测试，并且它们都通过了，那么重构是相对安全的。在大多数情况下，不需要新的测试。对现有测试进行小的修改应该就足够了。重构的预期结果是在修改代码之前和之后都通过所有测试。

# 开发实践

本节列出的实践着重于编写测试的最佳方式。编写最简单的代码来通过测试，因为这样可以确保更清晰和更干净的设计，并避免不必要的功能。

这个想法是，实现越简单，产品就越好、维护也更容易。这个想法遵循“保持简单，愚蠢”（KISS）原则。这个原则指出，大多数系统如果保持简单而不是复杂，就能发挥最佳作用；因此，简单性应该是设计的一个关键目标，不必要的复杂性应该被避免。先写断言，后行动，因为它能够在早期澄清需求和测试的目的。

一旦断言被写出来，测试的目的就清楚了，开发人员可以集中精力在实现这个断言的代码上，然后是实际的实现。在每个测试中最小化断言，避免断言轮盘赌；它允许执行更多的断言。

如果在一个测试方法中使用了多个断言，可能很难确定哪个导致了测试失败。当测试作为 CI 过程的一部分执行时，这种情况尤其常见。如果问题无法在开发人员的机器上重现（如果问题是由环境问题引起的情况可能是这样），修复问题可能会很困难和耗时。

当一个断言失败时，该测试方法的执行就会停止。如果该方法中有其他断言，它们将不会被运行，导致丢失了可以用于调试的信息。

最后但同样重要的是，多个断言会让测试的目标变得模糊。

这种做法并不意味着每个测试方法中应该总是只有一个`assert`。如果有其他断言来测试相同的逻辑条件或功能单元，它们可以在同一个方法中使用。

让我们通过一些例子来看：

```java
@Test 

public final void whenOneNumberIsUsedThenReturnValueIsThatSameNumber() { 
    Assert.assertEquals(3, StringCalculator.add("3")); 
} 

@Test 
public final void whenTwoNumbersAreUsedThenReturnValueIsTheirSum() { 
    Assert.assertEquals(3+6, StringCalculator.add("3,6")); 
} 
```

前面的代码包含了两个明确定义了测试目标的规范。通过阅读方法名称和查看`assert`，应该清楚地知道正在测试什么。考虑以下例子：

```java
@Test 
public final void whenNegativeNumbersAreUsedThenRuntimeExceptionIsThrown() { 
    RuntimeException exception = null; 
    try { 
        StringCalculator.add("3,-6,15,-18,46,33"); 
    } catch (RuntimeException e) { 
        exception = e; 
    } 
    Assert.assertNotNull("Exception was not thrown", exception); 
    Assert.assertEquals("Negatives not allowed: [-6, -18]",  
            exception.getMessage()); 
} 
```

这个规范有多个`assert`，但它们都在测试相同的逻辑功能单元。第一个`assert`确认异常存在，第二个确认它的消息是正确的。当在一个测试方法中使用多个断言时，它们都应该包含解释失败的消息。这样，调试失败的`assert`就更容易了。在每个测试方法中只有一个`assert`的情况下，消息是可以的，但不是必需的，因为从方法名称中应该清楚地知道测试的目标是什么：

```java
@Test 
public final void whenAddIsUsedThenItWorks() { 
    Assert.assertEquals(0, StringCalculator.add("")); 
    Assert.assertEquals(3, StringCalculator.add("3")); 
    Assert.assertEquals(3+6, StringCalculator.add("3,6")); 
    Assert.assertEquals(3+6+15+18+46+33, 
            StringCalculator.add("3,6,15,18,46,33")); 
    Assert.assertEquals(3+6+15, StringCalculator.add("3,6n15")); 
    Assert.assertEquals(3+6+15, 
            StringCalculator.add("//;n3;6;15"));    Assert.assertEquals(3+1000+6, 
            StringCalculator.add("3,1000,1001,6,1234")); 
} 
```

这个测试有很多断言。不清楚功能是什么，如果其中一个失败，不知道其余的是否会工作。当通过一些 CI 工具执行此测试时，可能很难理解失败。

不要在测试之间引入依赖关系。

好处：测试以任何顺序独立运行，无论是运行所有还是只运行一个子集。

每个测试都应该独立于其他测试。开发人员应该能够执行任何单独的测试，一组测试或所有测试。通常，由于测试运行器的设计，不能保证测试将按任何特定顺序执行。如果测试之间存在依赖关系，它们可能很容易在引入新的依赖关系时被破坏。

测试应该运行得快。

好处：这些测试经常被使用。

如果运行测试需要很长时间，开发人员将停止使用它们，或者只运行与他们正在进行的更改相关的一小部分测试。快速测试的好处，除了促进它们的使用，还包括快速反馈。问题被检测到得越早，修复起来就越容易。对产生问题的代码的了解仍然很新鲜。如果开发人员在等待测试执行完成时已经开始处理下一个功能，他们可能会决定推迟修复问题，直到开发了新功能。另一方面，如果他们放弃当前的工作来修复错误，那么在上下文切换中会浪费时间。

测试应该如此迅速，以至于开发人员可以在每次更改后运行所有测试而不感到无聊或沮丧。

使用测试替身。

好处：这减少了代码依赖性，测试执行将更快。

模拟是测试快速执行和专注于单个功能单元的先决条件。通过模拟被测试方法外部的依赖关系，开发人员能够专注于手头的任务，而不必花时间设置它们。在更大的团队中，这些依赖关系甚至可能尚未开发。此外，没有模拟的测试执行往往很慢。模拟的良好候选对象包括数据库、其他产品、服务等。

使用设置和拆卸方法。

好处：这允许在类或每个方法之前和之后执行设置和拆卸代码。

在许多情况下，一些代码需要在测试类之前或在类中的每个方法之前执行。为此，JUnit 有`@BeforeClass`和`@Before`注解，应该被用作设置阶段。`@BeforeClass`在类加载之前（在第一个测试方法运行之前）执行关联的方法。

`@Before`在每个测试运行之前执行关联的方法。当测试需要特定的前提条件时，应该使用这两个注解。最常见的例子是在（希望是内存中的）数据库中设置测试数据。

在相对的另一端是`@After`和`@AfterClass`注解，它们应该被用作拆卸阶段。它们的主要目的是销毁在设置阶段或测试本身创建的数据或状态。正如在先前的一个实践中所述，每个测试都应该独立于其他测试。此外，没有测试应该受到其他测试的影响。拆卸阶段有助于保持系统，就好像之前没有执行任何测试一样。

不要在测试中使用基类。

好处：它提供了测试的清晰度。

开发人员通常以与实现相同的方式处理测试代码。常见的错误之一是创建被测试类扩展的基类。这种做法避免了代码重复，但牺牲了测试的清晰度。在可能的情况下，应该避免或限制用于测试的基类。必须从测试类导航到其父类，再到父类的父类等，以便理解测试背后的逻辑，这经常会引入不必要的混乱。测试的清晰度应该比避免代码重复更重要。

# 工具

TDD、编码和测试一般都严重依赖于其他工具和流程。其中一些最重要的工具如下。它们每一个都是一个太大的主题，无法在本书中进行探讨，所以它们只会被简要描述。

代码覆盖率和 CI。

好处：它确保了一切都经过了测试。

代码覆盖率实践和工具在确定所有代码、分支和复杂性都经过测试方面非常有价值。其中一些工具如下：

+   JaCoCo ([`www.eclemma.org/jacoco/`](http://www.eclemma.org/jacoco/))

+   Clover ([`www.atlassian.com/software/clover`](https://www.atlassian.com/software/clover))

+   Cobertura ([`cobertura.github.io/cobertura/`](http://cobertura.github.io/cobertura/))

CI 工具对于除了最琐碎的项目之外的所有项目都是必不可少的。一些最常用的工具包括：

+   Jenkins ([`jenkins.io/`](https://jenkins.io/))

+   Hudson ([`hudson-ci.org/`](http://hudson-ci.org/))

+   Travis ([`travis-ci.org/`](https://travis-ci.org/))

+   Bamboo ([`www.atlassian.com/software/bamboo`](https://www.atlassian.com/software/bamboo)).

使用 TDD 和 BDD。

好处：开发人员单元测试和功能客户端测试都得到了覆盖。

虽然 TDD 与单元测试是一种很好的实践，但在许多情况下，它并不能提供项目所需的所有测试。TDD 开发速度快，有助于设计过程，并通过快速反馈提供信心。另一方面，BDD 更适合集成和功能测试，通过叙述提供了更好的需求收集过程，并且通过场景与客户沟通的方式更好。两者都应该被使用，它们共同提供了一个涉及所有利益相关者和团队成员的完整流程。TDD（基于单元测试）和 BDD 应该推动开发过程。我们建议使用 TDD 来实现高代码覆盖率和快速反馈，以及 BDD 作为自动化验收测试。虽然 TDD 大多是面向白盒测试，BDD 通常旨在进行黑盒测试。TDD 和 BDD 都试图专注于质量保证而不是质量控制。

# 总结

在本章中，我们首先简要概述了 TDD。我们了解了四种可以帮助提高软件质量的最佳实践。

在进入最后一章之前，我们将介绍 CI 和持续交付的概念，并通过一个例子强调 TDD 在整个流程中的重要性。
