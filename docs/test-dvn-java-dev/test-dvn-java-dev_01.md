# 第一章：我为什么要关心测试驱动开发？

这本书是由开发人员为开发人员编写的。因此，大部分学习将通过代码进行。每一章都将介绍一个或多个测试驱动开发（TDD）实践，并我们将通过解决 kata 来尝试掌握它们。在空手道中，kata 是一种练习，您可以在其中多次重复一个动作，每次都有一点改进。遵循相同的哲学，我们将从一章到下一章进行小而显著的改进。您将学会如何更好地设计和编码，减少上市时间，始终获得最新的文档，通过高质量的测试获得高代码覆盖率，并编写有效的代码。

每次旅行都有一个开始，这次也不例外。我们的目的地是具有 TDD 黑带的 Java 开发人员。

为了知道我们要去哪里，我们将不得不讨论并找到一些问题的答案，这些问题将定义我们的旅程。什么是 TDD？它是一种测试技术，还是其他东西？应用 TDD 的好处是什么？

本章的目标是获得 TDD 的概述，了解它是什么，并了解它为从业者提供的好处。

本章将涵盖以下主题：

+   理解 TDD

+   什么是 TDD？

+   测试

+   模拟

+   可执行文档

+   没有调试

# 为什么 TDD？

您可能是在敏捷或瀑布环境中工作。也许您有经过多年的艰苦工作经过实战检验的明确定义的程序，或者您刚刚开始自己的创业公司。无论情况如何，您可能至少面临以下一种或多种痛苦、问题或导致交付失败的原因：

+   您的团队在需求、规格或用户故事的创建过程中被排除在外

+   大多数，如果不是所有的测试都是手动的，或者根本没有测试

+   即使您有自动化测试，它们也无法检测到真正的问题

+   自动化测试是在项目提供任何真正价值的时候编写和执行的

+   总是有比花时间进行测试更紧急的事情

+   团队在测试、开发和功能分析部门之间分裂，他们经常不同步

+   由于担心会破坏某些东西，无法重构代码

+   维护成本太高

+   上市时间太长

+   客户觉得交付的东西不是他们要求的

+   文档永远不是最新的

+   您害怕部署到生产环境，因为结果是未知的

+   由于回归测试运行时间太长，通常无法部署到生产环境

+   团队花费太多时间试图弄清楚某个方法或类的作用

TDD 并不能神奇地解决所有这些问题。相反，它让我们走上了解决问题的道路。没有银弹，但如果有一种开发实践可以在许多层面上产生巨大影响，那就是 TDD。

TDD 加快了上市时间，使重构更容易，有助于创建更好的设计，并促进了更松散的耦合。

除了直接的好处外，TDD 还是许多其他实践的先决条件（持续交付就是其中之一）。更好的设计、编写良好的代码、更快的上市时间、最新的文档和扎实的测试覆盖率，是您通过应用 TDD 将实现的一些结果。

掌握 TDD 并不容易。即使学习了所有的理论，经历了最佳实践和反模式，旅程也刚刚开始。TDD 需要时间和大量的实践。这是一次漫长的旅程，不会在这本书中结束。事实上，它永远不会真正结束。总是有新的方法可以变得更加熟练和更快。然而，尽管成本很高，但好处更大。花足够的时间与 TDD 一起的人声称没有其他开发软件的方式。我们是其中之一，我们确信您也会成为其中之一。

我们坚信学习编码技术的最佳方式是通过编码。你不可能在地铁上读完这本书去上班。这不是一本可以在床上读的书。你必须动手编码。

在这一章中，我们将从基础知识开始；从下一章开始，你将通过阅读、编写和运行代码来学习。我们想说，当你完成这本书时，你将成为一名经验丰富的 TDD 程序员，但这是不正确的。在这本书结束时，你将对 TDD 感到舒适，并且在理论和实践上有一个坚实的基础。其余的取决于你，以及你在日常工作中应用它所建立的经验。

# 理解 TDD

此时，你可能会对自己说，“好吧，我明白 TDD 会给我带来一些好处，但 TDD 到底是什么？”TDD 是在实际实现之前编写测试的简单过程。这是传统方法的颠倒，传统方法是在编写代码之后进行测试。

# 红-绿-重构

TDD 是一个依赖于非常短的开发周期重复的过程。它基于**极限编程**（**XP**）的测试优先概念，鼓励简单的设计和高度的信心。驱动这一周期的过程被称为**红-绿-重构**。

这个过程本身很简单，它由几个重复的步骤组成：

1.  编写一个测试

1.  运行所有测试

1.  编写实现代码

1.  运行所有测试

1.  重构

1.  运行所有测试

由于测试是在实际实现之前编写的，所以它应该失败。如果没有失败，那么测试是错误的。它描述了已经存在的东西，或者写错了。在编写测试时处于绿色状态是一个假阳性的迹象。这样的测试应该被移除或重构。

在编写测试时，我们处于红色状态。当测试的实现完成时，所有测试都应该通过，然后我们就处于绿色状态了。

如果最后一个测试失败了，那么实现是错误的，应该进行更正。要么我们刚刚完成的测试是不正确的，要么该测试的实现未满足我们设定的规范。如果除了最后一个测试之外的任何测试都失败了，那么我们就破坏了一些东西，应该撤销更改。

当这种情况发生时，自然的反应是花费尽可能多的时间来修复代码，以确保所有测试都通过。然而，这是错误的。如果修复不是在几分钟内完成的，最好的做法是撤销更改。毕竟，不久前一切都是正常的。明显破坏了某些东西的实现显然是错误的，那么为什么不回到起点，重新考虑正确的实现方式呢？这样，我们浪费了几分钟在错误的实现上，而不是浪费更多的时间来纠正一开始就不正确的东西。现有的测试覆盖范围（不包括最后一个测试的实现）应该是神圣的。我们通过有意的重构来改变现有的代码，而不是作为修复最近编写的代码的一种方式。

不要使最后一个测试的实现最终化，而是提供足够的代码让这个测试通过。

以任何你想要的方式编写代码，但要快。一旦一切都是绿色的，我们就有信心有一种测试的安全网。从这一刻起，我们可以开始重构代码。这意味着我们正在使代码变得更好、更优化，而不是引入新功能。在重构进行时，所有测试都应该始终通过。

如果在重构过程中，其中一个测试失败了，说明重构破坏了现有的功能，和之前一样，改动应该被撤销。此时，我们不仅不改变任何功能，也不引入任何新的测试。我们所做的只是不断地改进代码，同时持续运行所有的测试，确保没有出现问题。同时，我们正在证明代码的正确性，减少未来的维护成本。

重构完成后，这个过程会重复。这是一个非常短的循环的无尽循环。

# 速度是关键

想象一场乒乓球比赛（或乒乓球）。比赛非常快速；有时甚至连专业运动员打比赛时都很难跟上球的速度。TDD 非常类似。TDD 老手往往不会在乒乓球桌的任一边花费超过一分钟的时间（测试和实现）。编写一个简短的测试并运行所有测试（乒），编写实现并运行所有测试（乓），编写另一个测试（乒），编写该测试的实现（乓），重构并确认所有测试都通过（得分），然后重复——乒，乓，乒，乓，乒，乓，得分，再发球。不要试图编写完美的代码。相反，尽量保持球的运动，直到你认为是时候得分（重构）。

从测试切换到实现（反之亦然）的时间应该以分钟（如果不是秒）计算。

# 这不是关于测试

**T**在**TDD**中经常被误解。TDD 是我们处理设计的方式。它是一种迫使我们在编写代码之前思考实现和代码需要做什么的方式。它是一种专注于需求和一次只实现一件事的方式——组织你的思绪并更好地结构代码。这并不意味着 TDD 产生的测试是无用的——它们远非如此。它们非常有用，它们让我们能够以极快的速度开发，而不用担心会出现问题。特别是在重构时。能够在重组代码的同时确保没有破坏任何功能，对其质量是一个巨大的提升。

TDD 的主要目标是可测试的代码设计，测试只是一个非常有用的副产品。

# 测试

尽管 TDD 的主要目标是代码设计的方法，测试仍然是 TDD 非常重要的一个方面，我们应该清楚地了解两大类技术，如下所示：

+   黑盒测试

+   白盒测试

# 黑盒测试

黑盒测试（也称为**功能测试**）将被测试的软件视为黑盒，不了解其内部。测试使用软件接口，并尝试确保它们按预期工作。只要接口的功能保持不变，即使内部发生了变化，测试也应该通过。测试人员知道程序应该做什么，但不知道它是如何做到的。黑盒测试是传统组织中最常用的测试类型，这些组织通常有一个独立的测试部门，特别是当测试人员不擅长编码并且难以理解时。这种技术为被测试的软件提供了外部视角。

黑盒测试的一些优点如下：

+   它对大段代码非常有效

+   不需要访问代码、理解代码和编写代码的能力

+   它为用户和开发者提供了分离的视角

黑盒测试的一些缺点如下：

+   它提供了有限的覆盖范围，因为只执行了一小部分测试场景

+   由于测试人员对软件内部知识的缺乏，可能导致测试效率低下

+   可能导致盲目覆盖，因为测试人员对应用程序的了解有限

如果测试驱动开发，通常以验收标准的形式进行，后来作为应该开发的定义。

自动化的黑盒测试依赖于某种形式的自动化，如 BDD。

# 白盒测试

白盒测试（也称为透明盒测试、玻璃盒测试、透明盒测试和结构测试）查看被测试软件的内部，并将这些知识作为测试过程的一部分。例如，如果在某些条件下应该抛出异常，测试可能希望重现这些条件。白盒测试需要对系统和编程技能有内部知识。它提供了对被测试软件的内部视角。

白盒测试的一些优点如下：

+   它在发现错误和问题方面非常有效

+   对被测试软件内部的了解对于彻底测试是有益的

+   它可以发现隐藏的错误

+   它鼓励程序员的内省

+   它有助于优化代码

+   由于对软件内部知识的要求，可以获得最大的覆盖率

白盒测试的一些缺点如下：

+   它可能无法发现未实现或缺失的功能

+   它需要对被测试软件的内部有高级别的了解

+   它需要代码访问

+   测试通常与生产代码的实现细节紧密耦合，导致在重构代码时出现不希望的测试失败

白盒测试几乎总是自动化的，并且在大多数情况下采用单元测试的形式。

当白盒测试在实施之前进行时，它采用 TDD 的形式。

# 质量检查和质量保证之间的区别

测试方法也可以通过它们试图实现的目标来区分。这些目标通常在质量检查（QC）和质量保证（QA）之间分开。虽然 QC 专注于缺陷识别，QA 试图防止它们。QC 是产品导向的，旨在确保结果符合预期。另一方面，QA 更专注于确保质量内建的过程。它试图确保以正确的方式完成正确的事情。

虽然在过去，质量检查在质量保证方面起着更重要的作用，但随着 TDD、ATDD 和后来的 BDD 的出现，焦点已经开始转向质量保证。

# 更好的测试

无论是使用黑盒测试、白盒测试还是两者兼而有之，它们的编写顺序都非常重要。

需求（规格和用户故事）在实现它们的代码之前编写。它们首先定义了代码，而不是相反。测试也是如此。如果它们是在代码完成后编写的，以某种方式，那么代码（以及它实现的功能）正在定义测试。由已经存在的应用程序定义的测试是有偏见的。它们倾向于确认代码的功能，而不是测试客户的期望是否得到满足，或者代码是否按预期行为。与手动测试相比，情况就不那么明显，因为它通常由一个独立的 QC 部门（尽管通常被称为 QA）进行（即使它通常被称为 QA）。他们倾向于在与开发人员隔离的测试定义上工作。这本身就会导致由于不可避免的沟通不良和“警察综合症”而引起的更大问题，测试人员不是试图帮助团队编写具有内建质量的应用程序，而是在过程结束时找到错误。我们越早发现问题，修复它们就越便宜。

以 TDD 方式编写的测试（包括其变体，如 ATDD 和 BDD）是试图从一开始就开发具有内建质量的应用程序。这是为了避免一开始就出现问题。

# 模拟

为了让测试快速运行并提供持续反馈，代码需要以这样一种方式组织，即方法、函数和类可以很容易地被替换为模拟和存根。这种类型的实际代码替换的常用术语是**测试替身**。执行速度可能会受到外部依赖的严重影响；例如，我们的代码可能需要与数据库通信。通过模拟外部依赖，我们能够大大提高速度。整个单元测试套件的执行时间应该以分钟计算，如果不是秒。以便易于模拟和存根的方式设计代码，迫使我们通过关注点的分离来更好地构建代码。

比速度更重要的是消除外部因素的好处。设置数据库、Web 服务器、外部 API 和其他可能需要的依赖项，既耗时又不可靠。在许多情况下，这些依赖项甚至可能不可用。例如，我们可能需要创建一个与数据库通信并让其他人创建模式的代码。没有模拟，我们需要等到模式设置好为止。

无论是否有模拟，代码都应该以便于用另一个依赖项替换的方式编写。

# 可执行文档

TDD（以及良好结构的测试）的另一个非常有用的方面是文档。在大多数情况下，通过查看测试来了解代码的功能要比查看实现本身容易得多。某些方法的目的是什么？看看与之相关的测试。应用程序 UI 的某些部分的期望功能是什么？看看与之相关的测试。以测试形式编写的文档是 TDD 的支柱之一，值得进一步解释。

（传统）软件文档的主要问题是大部分时间都不是最新的。一旦代码的某部分发生变化，文档就停止反映实际情况。这种情况几乎适用于任何类型的文档，需求和测试用例受到的影响最大。

需要记录代码的必要性通常表明代码本身写得不好。此外，无论我们如何努力，文档都不可避免地会过时。

开发人员不应依赖系统文档，因为它几乎永远不会是最新的。此外，没有文档能够提供与代码本身一样详细和最新的描述。

使用代码作为文档并不排除其他类型的文档。关键是要避免重复。如果通过阅读代码可以获取系统的细节，其他类型的文档可以提供快速指南和高层概述。非代码文档应该回答诸如系统的一般目的是什么，系统使用了哪些技术等问题。在许多情况下，一个简单的`README`就足以为开发人员提供快速入门。项目描述、环境设置、安装以及构建和打包说明等部分对新手非常有帮助。从那时起，代码就是圣经。

实现代码提供了所有所需的细节，而测试代码则充当了对生产代码背后意图的描述。

测试是可执行的文档，TDD 是创建和维护它的最常见方式。

假设某种形式的持续集成（CI）正在使用，如果测试文档的某部分不正确，它将失败并很快被修复。持续集成解决了测试文档不正确的问题，但并不能确保所有功能都有文档记录。因此（以及其他许多原因），测试文档应该以 TDD 的方式创建。如果在编写实现代码之前将所有功能定义为测试，并且所有测试执行成功，那么测试就可以作为开发人员可以使用的完整和最新的信息源。

我们应该怎么处理团队的其他成员？测试人员、客户、经理和其他非编码人员可能无法从生产和测试代码中获取必要的信息。

正如我们之前看到的，黑盒测试和白盒测试是最常见的两种测试类型。这种区分很重要，因为它也将测试人员分为那些知道如何编写或至少阅读代码的人（白盒测试）和那些不知道的人（黑盒测试）。在某些情况下，测试人员可以做两种类型的测试。然而，更多的情况是，他们不知道如何编码，因此开发人员可以使用的文档对他们来说是无用的。如果需要将文档与代码解耦，单元测试就不是一个好选择。这就是 BDD 出现的原因之一。

BDD 可以为非编码人员提供必要的文档，同时仍然保持 TDD 和自动化的优势。

客户需要能够定义系统的新功能，以及能够获取有关当前系统所有重要方面的信息。该文档不应该太技术化（代码不是选项），但它仍然必须始终保持最新。BDD 叙述和场景是提供这种类型文档的最佳方式之一。作为验收标准（在编写代码之前编写），经常执行（最好在每次提交时），并用自然语言编写的能力使 BDD 故事不仅始终保持最新，而且可供不想检查代码的人使用。

文档是软件的一个组成部分。与代码的任何其他部分一样，它需要经常进行测试，以确保它准确和最新。

具有准确和最新信息的唯一经济有效的方法是拥有可集成到 CI 系统中的可执行文档。

TDD 作为一种方法论是朝着这个方向前进的好方法。在低级别上，单元测试是最合适的。另一方面，BDD 提供了一种在功能级别上工作的好方法，同时保持了使用自然语言所实现的理解。

# 不要调试

我们（本书的作者）几乎从不调试我们正在处理的应用程序！

这个说法可能听起来很自大，但事实如此。我们几乎从不调试，因为很少有理由调试应用程序。当测试在编写代码之前编写，并且代码覆盖率很高时，我们可以非常有信心地认为应用程序按预期工作。这并不意味着使用 TDD 编写的应用程序没有错误-它们有。所有应用程序都有。然而，当发生这种情况时，通过简单查找未被测试覆盖的代码来隔离它们是很容易的。

测试本身可能不包括某些情况。在这种情况下，行动就是编写额外的测试。

通过高代码覆盖率，通过测试找到某个错误的原因比花时间逐行调试要快得多。

# 总结

在本章中，您了解了 TDD 实践的一般理解以及 TDD 是什么以及它不是什么。您了解到它是通过一个称为红-绿-重构的短小可重复的周期来设计代码的一种方式。失败是一种预期状态，不仅应该被接受，而且应该在整个 TDD 过程中得到强制执行。这个周期是如此短，以至于我们可以以很快的速度从一个阶段转移到另一个阶段。

在代码设计是主要目标的同时，整个 TDD 过程中创建的测试是一项宝贵的资产，应该被充分利用，并严重影响我们对传统测试实践的看法。我们经历了最常见的那些实践，比如白盒测试和黑盒测试，试图将它们放入 TDD 的视角，并展示它们可以互相带来的好处。

您发现模拟是编写测试时经常必不可少的重要工具。最后，我们讨论了测试如何可以和应该被用作可执行文档，以及 TDD 如何可以使调试变得不那么必要。

现在我们已经掌握了理论知识，是时候建立开发环境，概述和比较不同的测试框架和工具了。
