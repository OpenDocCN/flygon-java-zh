## 第二章：在可能的情况下，优先使用本地线程变量而不是静态和共享变量

线程本地变量是一种特殊类型的变量。每个任务都将拥有该变量的独立值，因此您不需要任何同步机制来保护对该变量的访问。

这可能听起来有点奇怪。每个对象都有类的属性的副本，那么为什么我们需要线程本地变量呢？考虑这种情况。您创建了一个`Runnable`任务，并且希望执行该任务的多个实例。您可以为要执行的每个线程创建一个`Runnable`对象，但另一种选择是创建一个`Runnable`对象，并使用该对象创建所有线程。在最后一种情况下，除非您使用`ThreadLocal`类，否则所有线程将可以访问类属性的相同副本。`ThreadLocal`类保证每个线程将访问其自己的变量实例，而无需使用锁、信号量或类似的类。

另一种情况可以利用线程本地变量的是静态属性。类的所有实例共享静态属性，但您可以使用`ThreadLocal`类来声明它们。在这种情况下，每个线程将可以访问其自己的副本。

您还可以选择使用类似`ConcurrentHashMap<Thread, MyType>`的东西，并像`var.get(Thread.currentThread())`或`var.put(Thread.currentThread(), newValue)`这样使用它。通常，这种方法比`ThreadLocal`慢得多，因为可能会有争用（`ThreadLocal`根本没有争用）。不过它也有一个优点：您可以完全清除映射，值将对每个线程消失；因此，有时使用这种方法是有用的。

## 找到算法更容易并行化的版本

我们可以将算法定义为解决问题的一系列步骤。解决同一个问题有不同的方法。有些更快，有些使用更少的资源，还有些更适合输入数据的特殊特征。例如，如果您想对一组数字进行排序，您可以使用已实现的多种排序算法之一。

在本章的前一节中，我们建议您使用顺序算法作为实现并发算法的起点。这种方法有两个主要优点：

+   您可以轻松测试并行算法的结果的正确性

+   你可以通过使用并发来衡量性能的改进。

但并非每个算法都可以并行化，至少不那么容易。您可能认为最佳起点是具有解决您想要并行化的问题的最佳性能的顺序算法，但这可能是一个错误的假设。您应该寻找一个可以轻松并行化的算法。然后，您可以将并发算法与具有最佳性能的顺序算法进行比较，以查看哪个提供了最佳吞吐量。

## 在可能的情况下使用不可变对象

在并发应用程序中，你可能会遇到的一个主要问题是数据竞争条件。正如我们之前解释过的，当两个或更多任务修改共享变量中存储的数据，并且对该变量的访问没有在关键部分内实现时，就会发生这种情况。

例如，当您使用 Java 等面向对象的语言时，您将应用程序实现为一组对象。每个对象都有一些属性和一些方法来读取和更改属性的值。如果一些任务共享一个对象并调用一个方法来更改该对象的属性的值，并且该方法没有受到同步机制的保护，那么您可能会遇到数据不一致的问题。

有一种特殊类型的对象称为不可变对象。它们的主要特征是初始化后无法修改任何属性。如果要修改属性的值，必须创建另一个对象。Java 中的`String`类是不可变对象的最佳示例。当您使用运算符（例如`=`或`+`）来改变 String 的值时，实际上是创建了一个新对象。

在并发应用中使用不可变对象有两个非常重要的优点：

+   您不需要任何同步机制来保护这些类的方法。如果两个任务想要修改相同的对象，它们将创建新对象，因此永远不会发生两个任务同时修改同一个对象的情况。

+   由于第一点的结论，您不会遇到任何数据不一致的问题。

不可变对象也有一个缺点。如果创建了太多对象，这可能会影响应用程序的吞吐量和内存使用。如果有一个简单的对象没有内部数据结构，通常将其设置为不可变是没有问题的。然而，使不可变的复杂对象，其中包含其他对象的集合，通常会导致严重的性能问题。

## 通过对锁进行排序来避免死锁

在并发应用程序中避免死锁情况的最佳机制之一是强制任务始终以相同的顺序获取共享资源。一个简单的方法是为每个资源分配一个编号。当任务需要多个资源时，必须按顺序请求它们。

例如，如果有两个任务 T1 和 T2，两者都需要两个资源 R1 和 R2，您可以强制两者首先请求 R1 资源，然后请求 R2 资源。您永远不会发生死锁。

另一方面，如果 T1 首先请求 R1，然后请求 R2，T2 首先请求 R2，然后请求 R1，就可能发生死锁。

例如，这个提示的不良使用如下。您有两个需要获取两个`Lock`对象的任务。它们尝试以不同的顺序获取锁：

```java
public void operation1() {
  lock1.lock();
  lock2.lock();
  ….
}
public void operation2() {
  lock2.lock();
  lock1.lock();
  …..
}
```

`operation1()`执行其第一句和`operation2()`也执行其第一句，因此它们将等待另一个`Lock`，从而导致死锁。

您可以通过以相同的顺序获取锁来避免这种情况。如果更改`operation2()`，则永远不会发生死锁，如下所示：

```java
public void operation2() {
  lock1.lock();
  lock2.lock();
  …..
}
```

## 使用原子变量而不是同步

当您需要在两个或多个任务之间共享数据时，必须使用同步机制来保护对该数据的访问，并避免任何数据不一致的问题。

在某些情况下，您可以使用`volatile`关键字而不使用同步机制。如果只有一个任务修改数据，其余任务读取数据，您可以使用`volatile`关键字而不会出现任何同步或数据不一致的问题。在其他情况下，您需要使用锁、`synchronized`关键字或任何其他同步方法。

在 Java 5 中，并发 API 包括一种称为原子变量的新类型变量。这些变量是支持单个变量上的原子操作的类。它们包括一个方法，称为`compareAndSet(oldValue, newValue)`，其中包括一种机制来检测是否在一步中将新值分配给变量。如果变量的值等于`oldValue`，则将其更改为`newValue`并返回 true。否则，返回`false`。还有更多类似方式工作的方法，例如`getAndIncrement()`或`getAndDecrement()`。这些方法也是原子的。

这种解决方案是无锁的；也就是说，它不使用锁或任何同步机制，因此其性能比任何同步解决方案都要好。

您可以在 Java 中使用的最重要的原子变量是：

+   `AtomicInteger`

+   `AtomicLong`

+   `AtomicReference`

+   `AtomicBoolean`

+   `LongAdder`

+   `DoubleAdder`

## 尽可能短地持有锁

锁，就像任何其他同步机制一样，允许您定义一个只有一个任务可以执行的关键部分。当一个任务执行关键部分时，想要执行它的其他任务被阻塞，并且必须等待关键部分的释放。应用程序是以顺序方式工作的。

您必须特别注意您在关键部分中包含的指令，因为您可能会降低应用程序的性能而没有意识到。您必须尽可能地使关键部分尽可能小，并且它必须只包含与其他任务共享数据的指令，这样应用程序以顺序方式执行的时间将最小化。

避免在关键部分内执行您无法控制的代码。例如，您正在编写一个接受用户定义的`Callable`的库，有时需要启动它。您不知道`Callable`中确切的内容。也许它会阻塞输入/输出，获取一些锁，调用库的其他方法，或者工作时间很长。因此，尽可能在您的库不持有任何锁时执行它。如果对您的算法来说这是不可能的，那么请在您的库文档中指定这种行为，并可能指定用户提供的代码的限制（例如，它不应该获取任何锁）。`ConcurrentHashMap`类的`compute()`方法中可以找到这种文档的一个很好的例子。

## 采取懒惰初始化的预防措施

懒惰初始化是一种延迟对象创建的机制，直到对象在应用程序中首次使用。它的主要优点是最小化内存使用，因为您只创建真正需要的对象，但在并发应用程序中可能会出现问题。

如果您有一个初始化对象的方法，并且这个方法同时被两个不同的任务调用，那么您可以初始化两个不同的对象。例如，这可能是单例类的问题，因为您只想创建这些类的一个对象。

这个问题的一个优雅的解决方案已经实现，就像延迟初始化持有者习惯（https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom）。

## 避免在关键部分内部使用阻塞操作

**阻塞操作**是那些阻塞调用它们的任务直到事件发生的操作。例如，当您从文件中读取数据或向控制台写入数据时，调用这些操作的任务必须等待它们完成。

如果您将这些操作之一包含在关键部分中，那么您会降低应用程序的性能，因为想要执行该关键部分的任务都无法执行它。在关键部分内部的任务正在等待 I/O 操作的完成，而其他任务则在等待关键部分。

除非必须，不要在关键部分内包含阻塞操作。

# 总结

并发编程包括所有必要的工具和技术，使多个任务或进程可以在计算机中同时运行，彼此通信和同步，而不会丢失数据或不一致。

我们通过介绍并发的基本概念开始了本章。您必须了解并理解并发、并行和同步等术语，才能充分理解本书的示例。然而，并发可能会产生一些问题，如数据竞争条件、死锁、活锁等。您还必须了解并发应用程序的潜在问题。这将帮助您识别和解决这些问题。

我们还解释了英特尔引入的将顺序算法转换为并发算法的简单五步方法，并向您展示了一些在 Java 语言中实现的并发设计模式以及在实现并发应用程序时需要考虑的一些提示。

最后，我们简要解释了 Java 并发 API 的组件。这是一个非常丰富的 API，具有低级和非常高级的机制，可以让您轻松实现强大的并发应用程序。我们还描述了 Java 内存模型，它决定了并发应用程序如何管理内存和内部指令的执行顺序。

在下一章中，您将学习如何使用执行器框架实现使用大量线程的应用程序。这允许您通过控制您使用的资源并减少线程创建引入的开销（它重用`Thread`对象来执行不同的任务）来执行大量线程。
