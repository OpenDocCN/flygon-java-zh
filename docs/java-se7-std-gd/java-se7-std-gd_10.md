# 附录 A：检验你的知识 - 答案

# 第一章：开始学习 Java

| 问题编号 | 答案 | 解释 |
| --- | --- | --- |
| 1 | a | 第二个命令行参数被显示。 |
| 2 | a，b 和 d | 选项 c 是不正确的，因为你不能将一个双精度值赋给一个整数变量。 |

# 第二章：Java 数据类型及其用法

| 问题编号 | 答案 | 解释 |
| --- | --- | --- |
| 1 | c | 你不能从静态方法中访问实例变量。 |
| 2 | c 和 e | 选项 a 是不正确的，因为单引号用于字符数据。选项 b 需要后缀`f`，如`3.14159f`。字节只接受-128 到+127 的值。 |
| 3 | b 和 d | 选项 a 是不正确的，因为实例变量需要与对象一起使用。选项 c 是不正确的，因为实例变量不能与类名一起使用。 |
| 4 | a，b 和 d | 没有`StringBuilder` `toInteger`方法。 |
| 5 | b | `lastIndexOf`方法接受一个 char 参数。`charAt`方法返回位置上的字母。`indexOf`的最后一个用法不同时接受字符串和 char 参数。 |
| 6 | c | 选项 a 只比较对象的相等性。选项 b 是不正确的，因为没有`matchCase`这样的方法。在选项 d 中，`equals`方法使用了两个字符串中不同的大小写。 |

# 第三章：决策结构

| 问题编号 | 答案 | 解释 |
| --- | --- | --- |
| 1 | b | `%`运算符是取模运算符，返回余数。 |
| 2 | a 和 c | 选项 b 评估为-24。选项 d 评估为 11。 |
| 3 | b | 位序列 0001000 向右移动 3 个位置，使用零填充。 |
| 4 | a 和 c | 选项 b 导致`i`和`j`之间的比较，返回一个布尔值。这个值不能与整数`k`进行比较。选项 d 在表达式`>k`之前需要一个操作数。 |
| 5 | b | 默认情况可以放置在 switch 语句的任何位置。由于除了第一个之外的所有情况都缺少 break 语句，流会穿过最后三个情况。虽然不常见，但常量可以用于 switch 语句。 |

# 第四章：使用数组和集合

| 问题编号 | 答案 | 解释 |
| --- | --- | --- |

| 1 | a 和 d | 数组声明中的元素数量在声明中没有使用。然而，我们可以使用以下内容：

```java
int arr[] = new int[5];
```

|

| 2 | b | 多维数组的至少第一个维度必须被指定。 |
| --- | --- | --- |
| 3 | a 和 c | 如果找到对象，`contains`方法将返回 true，`indexOf`接受一个对象引用并返回对象的索引（如果找到），否则返回-1。`indexOf`方法不接受整数参数，而`hasObject`方法不存在。 |

# 第五章：循环结构

| 问题编号 | 答案 | 解释 |
| --- | --- | --- |
| 1 | a 和 d | 其他选项不起作用，因为表达式不会求值为布尔值。 |
| 2 | b，c 和 d | 你不能在 for-each 语句中使用`[]`。 |
| 3 | a 和 b | 选项 c 需要在表达式`i < 5`周围加上括号。如果在`do`和`while`关键字之间使用了多个语句，则选项 d 需要一个块语句。 |
| 4 | a，b，c 和 d | 它们都是等价的。 |
| 5 | a | continue 语句跳过了`j`的值为`3`。 |

# 第六章：类、构造函数和方法

| 问题编号 | 答案 | 解释 |
| --- | --- | --- |
| 1 | a，c 和 d | 选项 b 未能正确初始化数组。 |
| 2 | c | 你不能从静态方法中访问实例方法。 |
| 3 | a | 重载方法时不考虑返回值。 |
| 4 | c 和 d | 最后一行是一个方法，恰好与构造函数同名。由于定义了构造函数但没有默认构造函数，该类没有默认构造函数。 |
| 5 | a 和 b | 在声明类时只能使用`private`和`public`关键字，`private`关键字只能用于内部类。 |
| 6 | c | 由于这些类在同一个包中，除了私有方法之外，所有方法都是可见的。 |
| 7 | d | `main`中的`i`变量没有被修改，因为它是按值传递的。虽然字符串是按引用传递的，但是在第三个方法中修改的是局部变量`s`，而不是`main`方法中的变量。 |

# 第七章：继承和多态

| 问题编号 | 答案 | 解释 |
| --- | --- | --- |
| 1 | a 和 d | 这导致`ClassC`成为`ClassA`的“孙子”。 |
| 2 | a 和 d | 重载只会发生在同一个类内。不需要有一个基类。一个常见的实现接口也可以用于多态行为。 |
| 3 | d | 其他方法不存在。 |
| 4 | b | 其他的会生成语法错误。 |
| 5 | c | 第一个答案只用作构造函数的第一个语句。第二个答案会生成语法错误。第四个选项会导致无限递归。 |
| 6 | a | 抽象类不一定要有抽象方法，可以扩展其他类，无论它们是否是抽象的。通常可以找到实现接口的抽象类。 |

# 第八章：在应用程序中处理异常

| 问题编号 | 答案 | 解释 |
| --- | --- | --- |
| --- |
| 1 | c 和 d | 已检查的异常是那些扩展了`Exception`类但没有扩展`RuntimeException`类的类。 |
| 2 | b 和 c | 应该首先捕获派生最多的类。在同一层次结构的类的顺序并不重要。 |
| 3 | d | 应该处理已检查的异常。它们可以使用 try-catch 块处理，也可以重新抛出到调用堆栈中更适合处理异常的另一个方法中。 |
| 4 | a 和 d | 我们通常可以处理已检查的异常，并且应该使用它们。 |
| 5 | a 和 d | `DivisionByZeroException`不存在。这里不执行任何文件操作。 |

# 第九章：Java 应用程序

| 问题编号 | 答案 | 解释 |
| --- | --- | --- |
| 1 | a 和 c | 包声明必须在任何其他代码之前。但是，注释可以出现在代码的任何位置。 |
| 2 | c | 如果存在的话，将返回来自基本资源包的字符串。 |
| 3 | c | 这个异常不存在。 |
