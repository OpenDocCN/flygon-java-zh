# 第一章

![](img/96afc5a2-c38b-4925-b5ae-ef376c779c08.jpg)[mapt.io](https://mapt.io/)

Mapt 是一个在线数字图书馆，为您提供超过 5,000 本书籍和视频的完全访问权限，以及行业领先的工具，帮助您规划个人发展并推动职业发展。欲了解更多信息，请访问我们的网站。

# 为什么订阅？

+   花更少的时间学习，更多时间编码，使用来自 4,000 多名行业专业人士的实用电子书和视频

+   通过专为您构建的技能计划来提高学习效果

+   每月获取免费电子书或视频

+   Mapt 是完全可搜索的

+   复制、粘贴、打印和书签内容

# PacktPub.com

您知道 Packt 提供每本书的电子书版本，提供 PDF 和 ePub 文件吗？您可以在[www.PacktPub.com](http://www.PacktPub.com)升级到电子书版本，并且作为印刷书籍客户，您有资格获得电子书折扣。欲了解更多详情，请通过`service@packtpub.com`与我们联系。

在[www.PacktPub.com](http://www.packtpub.com)上，您还可以阅读一系列免费技术文章，注册一系列免费新闻通讯，并获得 Packt 书籍和电子书的独家折扣和优惠。

# 目录

1.  标题页

1.  版权和鸣谢

1.  编程简介

1.  致谢

1.  贡献者

1.  关于作者

1.  关于评论者

1.  Packt 正在寻找像您这样的作者

1.  Packt 升级

1.  为什么订阅？

1.  PacktPub.com

1.  前言

1.  本书适合谁

1.  本书涵盖内容

1.  充分利用本书

1.  下载示例代码文件

1.  下载彩色图片

1.  使用的约定

1.  联系我们

1.  评论

1.  在您的计算机上安装 Java 虚拟机（JVM）

1.  什么是 Java？

1.  基本术语

1.  历史和流行度

1.  原则

1.  Java 平台、版本、版本和技术

1.  平台和版本

1.  版本

1.  技术

1.  Java SE 开发工具包（JDK）安装和配置

1.  从哪里开始

1.  包含 Java 安装程序的页面

1.  如何安装

1.  主要 Java 命令

1.  JVM 执行命令

1.  编译命令

1.  命令 jcmd 和其他命令

1.  练习- JDK 工具和实用程序

1.  答案

1.  摘要

1.  Java 语言基础

1.  Java 编程的基本术语

1.  字节码

1.  缺陷（错误）及其严重性和优先级

1.  Java 程序依赖

1.  语句

1.  方法

1.  类

1.  主类和主方法

1.  类和对象（实例）

1.  Java 类

1.  Java 对象（类实例）

1.  类（静态）和对象（实例）成员

1.  私有和公共

1.  静态成员

1.  对象（实例）成员

1.  方法重载

1.  接口、实现和继承

1.  接口

1.  实现

1.  继承

1.  java.lang.Object 类

1.  equals()方法

1.  hashCode()方法

1.  getClass()方法

1.  toString()方法

1.  clone()方法

1.  wait()和 notify()方法

1.  面向对象编程概念

1.  对象/类

1.  封装

1.  继承

1.  接口（抽象）

1.  多态

1.  练习 - 接口与抽象类

1.  答案

1.  摘要

1.  您的开发环境设置

1.  什么是开发环境？

1.  Java 编辑器是您的主要工具

1.  源代码编译

1.  代码共享

1.  代码和测试执行

1.  设置类路径

1.  手动设置

1.  在类路径上搜索

1.  IDE 自动设置类路径

1.  有很多 IDE

1.  NetBeans

1.  星际争霸

1.  IntelliJ IDEA

1.  安装和配置 IntelliJ IDEA

1.  下载和安装

1.  配置 IntelliJ IDEA

1.  练习 - 安装 NetBeans IDE

1.  答案

1.  摘要

1.  你的第一个 Java 项目

1.  什么是项目？

1.  项目的定义和起源

1.  与项目相关的术语

1.  项目的生命周期

1.  创建项目

1.  使用项目向导创建项目

1.  Maven 项目配置

1.  随时更改 IDE 设置

1.  编写应用程序代码

1.  Java 包声明

1.  创建包

1.  创建 MyApplication 类

1.  构建应用程序

1.  隐藏一些文件和目录

1.  创建 SimpleMath 类

1.  创建方法

1.  执行和单元测试应用程序

1.  使用 IDE 执行应用程序

1.  创建单元测试

1.  执行单元测试

1.  多少单元测试足够？

1.  练习 - JUnit @Before 和@After 注释

1.  答案

1.  摘要

1.  Java 语言元素和类型

1.  Java 语言元素是什么？

1.  输入元素

1.  类型

1.  注释

1.  标识符和变量

1.  标识符

1.  变量

1.  变量声明、定义和初始化

1.  最终变量（常量）

1.  保留和受限关键字

1.  保留关键字

1.  受限关键字

1.  分隔符

1.  分号“;”

1.  大括号“{}”

1.  括号“（）”

1.  括号“[]”

1.  逗号“，”

1.  句号“。”

1.  省略号“...”

1.  冒号“::”

1.  at 符号“@”

1.  原始类型和文字

1.  布尔类型

1.  整数类型

1.  浮点类型

1.  原始类型的默认值

1.  原始类型文字

1.  引用类型和字符串

1.  类类型

1.  接口类型

1.  数组

1.  引用类型的默认值

1.  引用类型文字

1.  字符串不可变性

1.  枚举类型

1.  将引用类型值作为方法参数传递

1.  练习-变量声明和初始化

1.  答案

1.  摘要

1.  接口，类和对象构造

1.  什么是 API？

1.  Java API

1.  命令行 API

1.  基于 HTTP 的 API

1.  软件组件 API

1.  接口和对象工厂作为 API

1.  接口

1.  对象工厂

1.  读取配置文件

1.  使用 json-simple 库

1.  使用 json-api 库

1.  单元测试

1.  计算器 API

1.  向 API 添加静态方法

1.  API 是完整的

1.  重载，重写和隐藏

1.  接口方法重载

1.  接口方法重写

1.  接口静态成员隐藏

1.  类成员隐藏

1.  实例方法重写

1.  实例方法重载

1.  this，super 和构造函数

1.  this 关键字及其用法

1.  关键字 super 及其用法

1.  构造函数

1.  最终变量，最终方法或最终类

1.  最终变量

1.  最终方法

1.  最终类

1.  练习-将类实例化限制为单个共享实例

1.  答案

1.  摘要

1.  包和可访问性（可见性）

1.  什么是导入？

1.  .java 文件和包的结构

1.  单类导入

1.  多类导入

1.  静态导入

1.  访问修饰符

1.  顶级类或接口的可访问性

1.  访问类或接口成员

1.  构造函数的可访问性与任何类成员相同

1.  封装

1.  数据隐藏和解耦

1.  灵活性，可维护性和重构

1.  可重用性

1.  [可测试性]

1.  [练习 - 遮蔽]

1.  [答案]

1.  [摘要]

1.  [面向对象设计（OOD）原则]

1.  [设计的目的是什么？]

1.  [项目的可行性]

1.  [需求收集和原型制作]

1.  [高级设计]

1.  [详细设计]

1.  [编码]

1.  [测试]

1.  [良好设计的路线图]

1.  [封装和编码到一个接口]

1.  [利用多态的优势]

1.  [尽可能解耦]

1.  [更喜欢聚合而不是继承]

1.  [这么多 OOD 原则，时间却那么少]

1.  [练习 - 设计模式]

1.  [答案]

1.  [摘要]

1.  [运算符、表达式和语句]

1.  [Java 编程的核心元素是什么？]

1.  [运算符]

1.  [算术一元（+   -）和二元运算符：+   -   *   /   %]

1.  [递增和递减一元运算符：++   --]

1.  [相等运算符：==   !=]

1.  [关系运算符：<   >   <=   >=]

1.  [逻辑运算符：!   &   |]

1.  [条件运算符：&&   ||   ? : (三元)]

1.  [赋值运算符（最受欢迎）：=   +=   -=   *=   /=   %=]

1.  [实例创建运算符：new]

1.  [类型比较运算符：instanceof]

1.  [更喜欢多态而不是 instanceof 运算符]

1.  [字段访问或方法调用运算符：.]

1.  [强制转换运算符：(目标类型)]

1.  [表达式]

1.  [语句]

1.  [运算符优先级和操作数的求值顺序]

1.  [运算符优先级]

1.  [操作数的求值顺序]

1.  [引用类型的扩宽和缩窄]

1.  [扩宽]

1.  [缩窄]

1.  [基本类型的扩宽和缩窄转换]

1.  [扩宽]

1.  [缩窄]

1.  [基本类型转换的方法]

1.  基本类型和引用类型之间的装箱和拆箱

1.  装箱

1.  拆箱

1.  引用类型的 equals()方法

1.  使用基类 Object 的实现

1.  覆盖 equals()方法

1.  使用父类中实现的标识

1.  String 类的 equals()方法

1.  基本类型的包装类中的 equals()方法

1.  练习-命名语句

1.  回答

1.  总结

1.  控制流语句

1.  什么是控制流？

1.  选择语句

1.  迭代语句

1.  分支语句

1.  异常处理语句

1.  选择语句

1.  如果

1.  如果...否则

1.  如果...否则如果...否则

1.  开关...情况

1.  迭代语句

1.  当

1.  做...当

1.  为

1.  增强

1.  具有多个初始化程序和表达式的 for 循环

1.  分支语句

1.  中断和标记中断

1.  继续和标记继续

1.  返回

1.  异常处理语句

1.  抛出

1.  尝试...捕获

1.  已检查和未检查（运行时）异常

1.  抛出

1.  自定义异常

1.  什么是异常处理？

1.  异常处理的一些最佳实践

1.  最后

1.  断言需要 JVM 选项-ea

1.  练习-无限循环

1.  回答

1.  总结

1.  JVM 进程和垃圾收集

1.  JVM 进程是什么？

1.  加载

1.  链接

1.  初始化

1.  实例化

1.  执行

1.  垃圾收集

1.  应用程序终止

1.  JVM 架构

1.  运行时数据区域

1.  类加载器

1.  执行引擎

1.  线程

1.  扩展 Thread 类

1.  什么是守护进程？

1.  运行扩展 Thread 的线程

1.  实现 Runnable

1.  实现 Runnable 的运行线程

1.  扩展 Thread vs 实现 Runnable

1.  [如何执行 main(String[])方法](cfe8bd2f-f88e-479a-8fb5-3d84bca3f968.xhtml)

1.  使用 IDE

1.  带有类路径上的类的命令行

1.  带有类路径上的.jar 文件的命令行

1.  带有可执行.jar 文件的命令行

1.  垃圾收集

1.  响应性，吞吐量和停止世界

1.  对象年龄和代

1.  当不可避免的停止世界

1.  练习-在运行应用程序时监视 JVM

1.  答案

1.  总结

1.  Java 标准和外部库

1.  标准和外部库是什么？

1.  Java 标准库

1.  java.lang

1.  java.util

1.  java.time

1.  java.io 和 java.nio

1.  java.sql 和 javax.sql

1.  java.net

1.  java.math

1.  java.awt，javax.swing 和 javafx

1.  Java 外部库

1.  org.junit

1.  org.mockito

1.  org.apache.log4j 和 org.slf4j

1.  org.apache.commons

1.  org.apache.commons.io

1.  org.apache.commons.lang 和 lang3

1.  org.apache.commons.codec.binary

1.  练习-比较 String.indexOf()和 StringUtils.indexOf()

1.  答案

1.  总结

1.  Java 集合

1.  什么是集合？

1.  java.util 包

1.  Apache Commons 集合

1.  集合 vs 数组

1.  这是我们将要讨论的内容

1.  List - ArrayList 保留顺序

1.  首选变量类型 List

1.  为什么叫 ArrayList？

1.  添加元素

1.  size(), isEmpty(), clear()

1.  迭代和流

1.  使用泛型添加

1.  添加集合

1.  实现 equals()和 hashCode()

1.  定位元素

1.  检索元素

1.  删除元素

1.  替换元素

1.  排序字符串和数字类型

1.  排序自定义对象

1.  与另一个集合比较

1.  转换为数组

1.  列表实现

1.  集合 - HashSet 不允许重复

1.  更喜欢变量类型 Set

1.  为什么叫 HashSet？

1.  添加元素

1.  size()，isEmpty()和 clear()

1.  迭代和流

1.  使用泛型添加

1.  添加集合

1.  实现 equals()和 hashCode()

1.  定位元素

1.  检索元素

1.  删除元素

1.  替换元素

1.  排序

1.  与另一个集合比较

1.  转换为数组

1.  集合实现

1.  Map - HashMap 通过键存储/检索对象

1.  更喜欢变量类型 Map

1.  为什么叫 HashMap？

1.  添加和可能替换

1.  size()，isEmpty()和 clear()

1.  迭代和流

1.  使用泛型添加

1.  添加另一个 Map

1.  实现 equals()和 hashCode()

1.  定位元素

1.  检索元素

1.  删除元素

1.  替换元素

1.  排序

1.  与另一个集合比较

1.  映射实现

1.  练习 - EnumSet 方法

1.  答案

1.  摘要

1.  管理集合和数组

1.  管理集合

1.  初始化集合

1.  集合构造函数

1.  实例初始化程序（双括号）

1.  静态初始化块

1.  of()的工厂方法

1.  使用其他对象和流

1.  不可变集合

1.  不可变与不可修改

1.  Immutable without methods of()

1.  Methods add() and put() confusion

1.  java.util.Collections class&#xA0;&#xA0;

1.  Copy&#xA0;

1.  Sort and equals()

1.  Reverse and rotate

1.  Search and equals()&#xA0;

1.  Comparing two collections

1.  Min and max elements

1.  Add and replace elements

1.  Shuffle and swap elements

1.  Converting to a checked collection

1.  Convert to a thread-safe collection

1.  Convert to another collection type

1.  Create enumeration and iterator

1.  Class collections4.CollectionUtils

1.  Manage arrays

1.  Initialize arrays

1.  Creation expression

1.  Array initializer

1.  Static initialization block

1.  From collection

1.  Other possible methods

1.  Class java.util.Arrays

1.  Class lang3.ArrayUtils

1.  Exercise &#x2013; Sort list of objects

1.  Answer

1.  Summary

1.  Managing Objects, Strings, Time, and Random Numbers

1.  Managing&#xA0;objects

1.  Class java.util.Objects

1.  equals() and deepEquals()&#xA0;

1.  hash() and hashCode()

1.  isNull() and nonNull()

1.  requireNonNull()&#xA0;

1.  checkIndex()

1.  compare()

1.  toString()

1.  Class lang3.ObjectUtils

1.  Managing strings

1.  StringBuilder&#xA0;and&#xA0;StringBuffer

1.  Class java.lang.String

1.  Constructors

1.  format()

1.  replace()

1.  compareTo()

1.  valueOf(Objectj)

1.  [valueOf(primitive or char[])](e82b485b-9a34-4663-a101-2c822ae90e9d.xhtml)

1.  [copyValueOf(char[])](94de094f-5a00-4c2c-ba22-a47e2f22b329.xhtml)

1.  indexOf() and substring()

1.  contains() and&#xA0;matches()

1.  split(),&#xA0;concat(), and join()

1.  startsWith() and endsWith()

1.  equals() and&#xA0;equalsIgnoreCase()

1.  contentEquals() and copyValueOf()

1.  length(), isEmpty(), and hashCode()

1.  trim()，toLowerCase()和 toUpperCase()

1.  getBytes()，getChars()和 toCharArray()

1.  通过索引或流获取代码点

1.  Class lang3.StringUtils

1.  管理时间

1.  java.time.LocalDate

1.  java.time.LocalTime

1.  java.time.LocalDateTime

1.  周期和持续时间

1.  管理随机数

1.  方法 java.lang.Math.random()

1.  Class java.util.Random

1.  练习-Objects.equals()结果

1.  答案

1.  摘要

1.  数据库编程

1.  什么是 Java 数据库连接（JDBC）？

1.  连接到数据库

1.  关闭数据库连接

1.  结构化查询语言（SQL）

1.  创建数据库及其结构

1.  创建和删除数据库及其用户

1.  创建，更改和删除表

1.  创建，读取，更新和删除（CRUD）数据

1.  INSERT 语句

1.  SELECT 语句

1.  UPDATE 语句

1.  DELETE 语句

1.  使用 PreparedStatement 类

1.  练习-选择唯一的名字

1.  答案

1.  摘要

1.  Lambda 表达式和函数式编程

1.  函数式编程

1.  什么是功能接口？

1.  可直接使用的标准功能接口

1.  Function<T, R>

1.  Consumer<T>

1.  Supplier<T>

1.  Predicate<T>

1.  其他标准功能接口

1.  链接标准函数

1.  链接两个 Function<T,R>

1.  链接两个 Consumer<T>

1.  链接两个 Predicate<T>

1.  identity()和其他默认方法

1.  Lambda 表达式

1.  什么是 lambda 表达式？

1.  重新实现函数

1.  Lambda 限制

1.  有效的最终局部变量

1.  this 关键字解释

1.  方法引用

1.  练习 - 使用方法引用创建新对象

1.  答案

1.  总结

1.  流和管道

1.  什么是流？

1.  流操作

1.  创建流

1.  流接口

1.  empty()，of(T t)，ofNullable(T t)

1.  iterate(Object, UnaryOperator)

1.  concat(Stream a, Stream b)

1.  generate(Supplier)

1.  of(T... values)

1.  Stream.Builder 接口

1.  其他类和接口

1.  中间操作

1.  过滤

1.  映射

1.  排序

1.  窥视

1.  终端操作

1.  处理每个元素

1.  计算所有元素的数量

1.  匹配所有、任意或无

1.  查找任意或第一个

1.  Optional 类

1.  最小和最大

1.  toArray()操作

1.  reduce 操作

1.  收集操作

1.  类收集器

1.  数值流接口

1.  创建流

1.  range()，rangeClosed()

1.  中间操作

1.  boxed()和 mapToObj()

1.  mapToInt()，mapToLong()和 mapToDouble()

1.  flatMapToInt()，flatMapToLong()和 flatMapToDouble()

1.  终端操作

1.  sum()和 average()

1.  并行处理

1.  无状态和有状态操作

1.  顺序或并行处理？

1.  练习 - 将所有流元素相乘

1.  答案

1.  总结

1.  响应式系统

1.  如何快速处理大量数据

1.  异步

1.  顺序与并行流

1.  使用 CompletableFuture 类

1.  非阻塞

1.  java.io 与 java.nio 包

1.  事件循环或运行循环

1.  分布式

1.  可扩展的

1.  响应式

1.  响应式的

1.  有弹性的

1.  Elastic

1.  消息驱动的

1.  微服务

1.  Vert.x 基础知识

1.  HTTP 服务器作为微服务

1.  周期性服务作为微服务

1.  HTTP 客户端作为微服务

1.  其他微服务

1.  响应式系统

1.  消息驱动系统

1.  消息消费者

1.  消息发送者

1.  消息发布者

1.  现实检验

1.  练习 - 创建 io.reactivex.Observable

1.  答案

1.  摘要

1.  您可能喜欢的其他书籍

1.  留下评论 - 让其他读者知道您的想法
