# JVM 进程和垃圾回收

本章使读者能够深入了解 JVM 并了解其进程。 JVM 的结构和行为比仅仅按照编码逻辑执行一系列指令的执行器更复杂。 JVM 会找到并加载应用程序请求的`.class`文件到内存中，对其进行验证，解释字节码（将其转换为特定平台的二进制代码），并将生成的机器代码传递给中央处理器（或处理器）进行执行，除了应用程序线程外，还使用几个服务线程。其中一个名为垃圾回收的服务线程执行重要任务，即释放未使用对象的内存。

在本章中，我们将涵盖以下主题：

+   JVM 进程是什么？

+   JVM 架构

+   垃圾回收

+   线程

+   练习-在运行应用程序时监视 JVM

# JVM 进程是什么？

正如我们在第一章中已经确定的那样，*计算机上的 Java 虚拟机（JVM）*，JVM 对 Java 语言和源代码一无所知。 它只知道如何读取字节码。 它从`.class`文件中读取字节码和其他信息，解释它（将其转换为特定微处理器的二进制代码序列），并将结果传递给执行它的计算机。

在谈论它时，程序员经常将 JVM 称为* JVM 实例*或*进程*。 这是因为每次执行`java`命令时，都会启动一个新的 JVM *实例*，专门用于在单独的进程中运行特定应用程序，并分配内存大小（默认或作为命令选项传递）。 在这个 JVM 进程内部，多个线程正在运行，每个线程都有自己分配的内存； 一些是 JVM 创建的服务线程，而其他是应用程序创建和控制的应用程序线程。

线程是轻量级进程，需要比 JVM 执行进程更少的资源分配。

这是 JVM 执行编译代码的大局观。 但是，如果您仔细观察并阅读 JVM 规范，您会发现与 JVM 相关的“进程”一词被重复使用了很多次。 JVM 规范确定了 JVM 内部运行的其他几个进程，程序员通常不提及它们，除了可能是类加载过程。

这是因为大多数情况下，人们可以成功地编写和执行 Java 程序，而无需了解 JVM 的更多信息。 但是偶尔，对 JVM 内部工作原理的一些一般了解有助于确定某些相关问题的根本原因。 这就是为什么在本节中，我们将简要概述 JVM 内部发生的所有进程。 然后，在接下来的几节中，我们将更详细地讨论 JVM 的内存结构和 JVM 功能的其他一些方面，这可能对程序员有用。

有两个子系统运行所有 JVM 内部进程：

+   类加载器，读取`.class`文件并使用类相关数据填充 JVM 内存中的方法区域：

+   静态字段

+   方法字节码

+   描述类的类元数据

+   执行引擎，使用以下内容执行字节码：

+   堆区用于对象实例化

+   Java 和本地方法堆栈用于跟踪调用的方法

+   垃圾回收过程以回收内存

运行在主 JVM 进程内部的进程列表包括：

+   类加载器执行的进程：

+   类加载

+   类链接

+   类初始化

+   执行引擎执行的进程：

+   类实例化

+   方法执行

+   垃圾回收

+   应用程序终止

JVM 架构可以描述为具有两个子系统 - 类加载器和执行引擎 - 它们使用运行时数据内存区域运行服务进程和应用程序线程：方法区域，堆和应用程序线程堆栈。

前面的列表可能会让你觉得这些过程是按顺序执行的。在某种程度上，如果我们只谈论一个类的话，这是正确的。在加载之前无法对类做任何操作。只有在完成所有先前的过程之后，方法的执行才能开始。然而，例如垃圾回收并不会在对象停止使用后立即发生（请参阅下一节，*垃圾回收*）。此外，应用程序可能在发生未处理的异常或其他错误时随时退出。

JVM 规范只对类加载器进程进行了规定。执行引擎的实现在很大程度上取决于每个供应商。它基于语言语义和实现作者设定的性能目标。

执行引擎的过程不受 JVM 规范的约束。有常识、传统、已知和经过验证的解决方案，以及 Java 语言规范可以指导 JVM 供应商的实现决策，但没有单一的监管文件。好消息是，最流行的 JVM 使用类似的解决方案，或者至少从入门课程的高层来看是这样的。有关特定供应商的详细信息，请参阅维基百科上的*Java 虚拟机比较*（[`en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines`](https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines)）和其他互联网上可用的来源。

有了这个理解，让我们更详细地描述之前列出的七个过程中的每一个。

# 加载

根据 JVM 规范，加载阶段包括通过其名称找到`.class`文件并在内存中创建其表示。

要加载的第一个类是在命令行中传递的带有`main(String[])`方法的类。我们之前在第四章中描述过它，*你的第一个 Java 项目*。类加载器读取`.class`文件，根据内部数据结构解析它，并用静态字段和方法字节码填充方法区。它还创建了描述该类的`java.lang.Class`的实例。然后，类加载器链接（见*链接*部分）和初始化（见*初始化*部分）该类，并将其传递给执行引擎以运行其字节码。

在第四章中的第一个项目，*你的第一个 Java 项目*中，`main(String[])`方法没有使用任何其他方法或类。但在实际应用程序中，`main(String[])`方法是应用程序的入口。如果它调用另一个类的方法，那么必须在类路径上找到该类并读取、解析和初始化；只有这样它的方法才能被执行。依此类推。这就是 Java 应用程序的启动和运行方式。

在接下来的部分*如何执行 main(String[])方法*中，我们将展示 Java 应用程序可以启动的几种方式，包括使用带有清单的可执行`.jar`文件。

每个类都允许有一个`main(String[])`方法，通常也有。这样的方法用于独立运行类作为独立应用程序进行测试或演示。这样的方法的存在并不使类成为主类。只有在`java`命令行或`.jar`文件清单中标识为主类时，该类才成为主类。

说了这些，让我们继续讨论加载过程。

如果查看`java.lang.Class`的 API，你不会在那里看到公共构造函数。类加载器会自动创建它的实例，并且顺便说一句，这是由`getClass()`方法返回的相同实例，你可以在任何对象上调用该方法。它不携带类的静态数据（这些数据在方法区中维护）或状态（它们在执行期间创建的对象中）。它也不包含方法的字节码（这也存储在方法区中）。相反，`Class`实例提供描述类的元数据 - 其名称、包、字段、构造函数、方法签名等。这就是为什么它不仅对 JVM 有用，对应用程序代码也有用，正如我们已经在一些示例中看到的。

类加载器在内存中创建并由执行引擎维护的所有数据称为类型的二进制表示。

如果`.class`文件存在错误或不符合特定格式，该过程将被终止。这意味着加载过程会对加载的类格式及其字节码进行一些验证。但更多的验证将在下一个称为**链接**的过程开始时进行。

以下是加载过程的高级描述。它执行三项任务：

+   查找并读取`.class`文件

+   根据内部数据结构将其解析到方法区

+   创建一个携带类元数据的`java.lang.Class`的实例

# 链接

根据 JVM 规范，链接是解析已加载类的引用，以便执行类的方法。

虽然 JVM 可以合理地期望`.class`文件是由 Java 编译器生成的，并且所有指令都满足语言的约束和要求，但无法保证加载的文件是由已知的编译器实现或根本没有编译器生成的。这就是为什么链接过程的第一步是*验证*，以确保类的二进制表示在结构上是正确的：每个方法调用的参数与方法描述符兼容，返回指令与其方法的返回类型匹配，依此类推。

验证成功完成后，下一步是*准备*。接口或类（静态）变量在方法区中创建，并初始化为其类型的默认值。其他类型的初始化（由程序员指定的显式赋值和静态初始化块）被推迟到称为**初始化**的过程中（请参阅下一节*初始化*）。

如果加载的字节码引用其他方法、接口或类，则符号引用将被解析为指向方法区的具体引用，这是通过*解析*过程完成的。如果所引用的接口和类尚未加载，类加载器会找到它们并根据需要加载它们。

以下是链接过程的高级描述。它执行三项任务：

+   验证类或接口的二进制表示

+   在方法区中准备静态字段

+   将符号引用解析为指向方法区的具体引用

# 初始化

根据 JVM 规范，初始化是通过执行类初始化方法来完成的。

这是程序员定义的初始化（在静态块和静态赋值中）进行的时候，除非类已经在另一个类的请求下进行了初始化。

这个陈述的最后一部分很重要，因为该类可能会被不同（已加载）方法多次请求，并且因为 JVM 进程由不同线程执行（参见*线程*部分中线程的定义），可能会同时访问同一个类。因此，需要在不同线程之间进行协调（也称为同步），这大大复杂了 JVM 的实现。

# 实例化

从技术上讲，由`new`操作符触发的实例化过程是执行的第一步，这一部分可能不存在。但是，如果`main(String[])`方法（静态方法）只使用其他类的静态方法，实例化就永远不会发生。这就是为什么将这个过程与执行分开是合理的。此外，这个活动有非常具体的任务：

+   在堆区为对象（其状态）分配内存

+   将实例字段初始化为默认值

+   为 Java 和本地方法创建线程堆栈

执行从第一个方法（不是构造函数）准备执行开始。为每个应用程序线程创建一个专用的运行时堆栈，在其中捕获每个方法调用的堆栈帧。如果发生异常，我们可以从当前堆栈帧中调用`printStackTrace()`方法获取数据。

# 执行

当`main(String[])`方法开始执行时，将创建第一个应用程序线程（称为*主*线程）。它可以创建其他应用程序线程。执行引擎读取字节码，解释它们，并将二进制代码发送到微处理器执行。它还维护了每个方法被调用的次数和频率的计数。如果计数超过一定阈值，执行引擎将使用一个称为 JIT 编译器的编译器，将方法的字节码编译成本地代码。下次调用该方法时，它将准备好而无需解释。这大大提高了代码的性能。

当前正在执行的指令和下一条指令的地址都保存在**程序计数器**（**PC**）寄存器中。每个线程都有自己专用的 PC 寄存器。这也提高了性能并跟踪执行情况。

# 垃圾收集

**垃圾收集器**（**GC**）运行的过程是识别不再被引用的对象，因此可以从内存中删除。有一个 Java 静态方法`System.gc()`，可以通过编程方式触发垃圾收集，但不能保证立即执行。每次 GC 循环都会影响应用程序的性能，因此 JVM 必须在内存可用性和执行字节码的速度之间保持平衡。

# 应用程序终止

应用程序可以通过多种方式（以及通过编程方式）终止（并停止 JVM）：

+   正常终止而没有错误状态码

+   由于未处理的异常或强制的编程方式退出而导致的异常终止，无论是否带有错误状态码

如果没有异常和无限循环，`main(String[])`方法将通过`return`语句或在执行其最后一条语句后完成。一旦发生这种情况，主应用程序线程将控制流返回给 JVM，JVM 也停止执行。

这是一个幸福的结局，许多应用程序在现实生活中也享受着这种结局。除了我们展示了异常或无限循环的例外情况，大多数示例也都成功结束了。

然而，Java 应用程序还有其他退出方式，其中一些方式也相当优雅。其他方式则不那么优雅。

如果主应用程序线程创建了子线程，或者换句话说，程序员编写了生成其他线程的代码，即使优雅地退出也可能不那么容易。这完全取决于创建的子线程的类型。如果其中任何一个是`用户`线程（默认情况下），那么即使主线程退出后，JVM 实例也会继续运行。

只有在所有`用户`线程完成后，JVM 实例才会停止。主线程可以请求子`用户`线程完成（我们将在下一节*线程*中讨论这一点）。但在退出之前，JVM 会继续运行，这意味着应用程序仍在运行。

但是，如果所有子线程都是`守护`线程（请参阅下一节*线程*），或者没有正在运行的子线程，那么一旦主应用程序线程退出，JVM 实例就会停止运行。

在没有强制终止的情况下，JVM 实例会继续运行，直到主应用程序线程和所有子`用户`线程完成。如果没有子`用户`线程或者所有子线程都是`守护`线程，那么一旦主应用程序线程退出，JVM 就会停止运行。

在异常情况下应用程序如何退出取决于代码设计。我们在上一章讨论异常处理的最佳实践时已经提到过。如果线程在`main(String[])`或类似高级方法中的`try...catch`块中捕获了所有异常，那么控制流将返回到应用程序代码，并由应用程序（以及编写代码的程序员）决定如何继续——尝试恢复、记录错误并继续，或者退出。

另一方面，如果异常仍未处理并传播到 JVM 代码中，那么发生异常的线程将停止执行并退出。然后，将发生以下情况之一：

+   如果没有其他线程，则 JVM 停止执行并返回错误代码和堆栈跟踪

+   如果出现未处理的异常的线程不是主线程，则其他线程（如果存在）会继续运行

+   如果主线程抛出未处理的异常，并且子线程（如果存在）是守护线程，则它们也会退出

+   如果至少有一个用户子线程，JVM 会继续运行，直到所有用户线程退出

还有一些编程方法可以强制应用程序停止：

+   `System.exit(0);`

+   `Runtime.getRuntime().exit(0);`

+   `Runtime.getRuntime().halt(0);`

所有前述方法都会强制 JVM 停止执行任何线程，并以作为参数传递的状态代码（在我们的示例中为 0）退出：

+   零表示正常终止

+   非零值表示异常终止

如果 Java 命令是由某个脚本或其他系统启动的，则状态代码的值可用于自动化决定下一步的操作。但这已经超出了应用程序和 Java 代码的范围。

前两种方法具有相同的功能，因为`System.exit()`的实现方式如下：

```java

public static void exit(int status) {

Runtime.getRuntime().exit(status);

}

```

要在 IDE 中查看源代码，只需单击该方法。

当某个线程调用`Runtime`或`System`类的`exit()`方法，或者`Runtime`类的`halt()`方法，并且退出或中止操作被安全管理器允许时，Java 虚拟机退出。

`exit()`和`halt()`之间的区别在于`halt()`会立即强制 JVM 退出，而`exit()`会执行可以使用`Runtime.addShutdownHook()`方法设置的附加操作。

但所有这些选项在主流编程中很少使用，因此我们已经超出了本书的范围。

# JVM 架构

JVM 架构可以用内存中的运行时数据结构和使用运行时数据的两个子系统——类加载器和执行引擎来描述。

# 运行时数据区

JVM 内存的每个运行时数据区都属于两个类别之一：

+   共享区域，包括以下内容：

+   **方法区**：类元数据，静态字段，方法字节码

+   **堆区**：对象（状态）

+   不共享区域，专门为每个应用程序线程而设，包括以下内容：

+   **Java 堆栈**：当前和调用者帧，每个帧保持 Java（非本地）方法调用的状态：

+   本地变量的值

+   方法参数值

+   中间计算的操作数的值（操作数栈）

+   方法返回值（如果有）

+   **程序计数器（PC）寄存器**：下一条要执行的指令

+   **本地方法堆栈**：本地方法调用的状态

我们已经讨论过，程序员在使用引用类型时必须小心，不要修改对象本身，除非需要这样做。在多线程应用程序中，如果对象的引用可以在线程之间传递，就必须特别小心，因为可能会同时修改相同的数据。

光明的一面是，这样的共享区域可以并且经常被用作线程之间的通信手段。我们将在即将到来的*Threads*部分讨论这个问题。

# 类加载器

类加载器执行以下三个功能：

+   读取`.class`文件

+   填充方法区

+   初始化程序员未初始化的静态字段

# 执行引擎

执行引擎执行以下操作：

+   在堆区实例化对象

+   使用程序员编写的初始化器初始化静态和实例字段

+   向 Java 堆栈添加/删除帧

+   更新 PC 寄存器以执行下一条指令

+   维护本地方法堆栈

+   保持方法调用的计数并编译流行的方法

+   完成对象

+   运行垃圾回收

+   终止应用程序

# 线程

正如我们已经提到的，主应用程序线程可以创建其他 - 子 - 线程，并让它们并行运行，无论是通过时间切片共享同一个核心，还是为每个线程分配一个专用的 CPU。可以使用实现了功能接口`Runnable`的类`java.lang.Thread`来实现。如果接口只有一个抽象方法，就称为功能接口（我们将在第十七章中讨论功能接口，*Lambda 表达式和函数式编程*）。`Runnable`接口包含一个方法`run()`。 

有两种方法创建新线程：

+   扩展`Thread`类

+   实现`Runnable`接口，并将实现的对象传递到类`Thread`的构造函数中

# 扩展 Thread 类

无论使用什么方法，最终我们都会得到一个具有`start()`方法的`Thread`类对象。这个方法调用开始线程执行。让我们看一个例子。让我们创建一个名为`AThread`的类，它扩展了`Thread`并重写了它的`run()`方法：

```java

public class AThread extends Thread {

int i1, i2;

public AThread(int i1, int i2) {

this.i1 = i1;

this.i2 = i2;

}

public void run() {

for (int i = i1; i <= i2; i++) {

System.out.println("child thread " + (isDaemon() ? "daemon" : "user") + " " + i);

try {

TimeUnit.SECONDS.sleep(1);

} catch (InterruptedException e) {

e.printStackTrace();

}

}

}

}

```

重写`run()`方法很重要，否则线程将不执行任何操作。`Thread`类实现了`Runnable`接口，并且有`run()`方法的实现，但它看起来如下：

```java

public void run() {

if (target != null) {

target.run();

}

}

```

变量`target`保存在构造函数中传递的值：

```java

public Thread(Runnable target) {

init(null, target, "Thread-" + nextThreadNum(), 0);

}

```

但是我们的`AThread`类没有向父类`Target`传递任何值；变量 target 是`null`，所以`Thread`类中的`run()`方法不执行任何操作。

现在让我们使用我们新创建的线程。我们期望它将变量`i`从`i1`增加到`i2`（这些是通过构造函数传递的参数），并打印其值以及`isDaemon()`方法返回的布尔值，然后等待（休眠）1 秒并再次增加变量`i`。

# 什么是守护进程？

“守护”一词源自古希腊语，意思是介于神和人之间的神性或超自然存在，以及内在或随从精神或激励力量。但在计算机科学中，这个术语有更加平凡的用法，用于指代作为后台进程运行的计算机程序，而不是受交互式用户直接控制。这就是为什么 Java 中有两种类型的线程：

+   用户线程（默认），由应用程序发起（主线程就是这样的一个示例）

+   在支持用户线程活动的后台运行的守护线程（垃圾收集是守护线程的一个示例）

这就是为什么所有守护线程在最后一个用户线程退出或 JVM 在未处理的异常后终止之后立即退出。

# 扩展线程运行

让我们使用我们的新类`AThread`来演示我们所描述的行为。这是我们首先要运行的代码：

```java

Thread thr1 = new AThread（1,4）;

thr1.start（）;

Thread thr2 = new AThread（11,14）;

thr2.setDaemon（true）;

thr2.start（）;

尝试 {

TimeUnit.SECONDS.sleep（1）;

} 捕获（InterruptedException e）{

e.printStackTrace（）;

}

System.out.println（“主线程存在”）;

```

在前面的代码中，我们创建并立即启动了两个线程-用户线程`thr1`和守护线程`thr2`。实际上，还有一个名为`main`的用户线程，所以我们运行了两个用户线程和一个守护线程。每个子线程将打印递增的数字四次，每次打印后暂停 1 秒。这意味着每个线程将运行 4 秒。主线程也会暂停 1 秒，但只有一次，所以它将运行大约 1 秒。然后，它打印“主线程存在”并退出。如果我们运行此代码，将看到以下输出：

！[]（img / 42afcacb-82d0-414b-afd4-e5d36be0c2d5.png）

我们在一个共享的 CPU 上执行此代码，因此，尽管所有三个线程都在同时运行，但它们只能顺序使用 CPU。因此，它们不能并行运行。在多核计算机上，每个线程可以在不同的 CPU 上执行，输出可能略有不同，但差别不大。无论如何，您会看到主线程首先退出（大约 1 秒后），子线程运行直到完成，每个线程总共运行大约 4 秒。

让用户线程只运行 2 秒：

```java

Thread thr1 = new AThread（1,2）;

thr1.start（）;

```

结果是：

！[]（img / ab8a6642-440f-4a0b-af2e-1589b74c8613.png）

如您所见，守护线程没有完全运行。它成功打印了 13，可能仅因为它在 JVM 响应最后一个用户线程退出之前已将消息发送到输出设备。

# 实现 Runnable

创建线程的第二种方法是使用实现`Runnable`的类。以下是一个几乎与类`AThread`具有完全相同功能的类的示例：

```java

public class ARunnable implements Runnable {

int i1，i2;

public ARunnable（int i1，int i2）{

this.i1 = i1;

this.i2 = i2;

}

public void run（）{

for（int i = i1; i <= i2; i ++）{

System.out.println（“子线程”+ i）;

尝试 {

TimeUnit.SECONDS.sleep（1）;

} 捕获（InterruptedException e）{

e.printStackTrace（）;

}

}

}

}

```

唯一的区别是`Runnable`接口中没有`isDaemon（）`方法，因此我们无法打印线程是否为守护线程。

# 运行实现 Runnable 的线程

以下是如何使用此类创建两个子线程-一个用户线程和另一个守护线程-与我们之前所做的完全相同：

```java

Thread thr1 = new Thread（new ARunnable（1,4））;

thr1.start（）;

Thread thr2 = new Thread（new ARunnable（11,14））;

thr2.setDaemon（true）;

thr2.start（）;

尝试 {

TimeUnit.SECONDS.sleep（1）;

} 捕获（InterruptedException e）{

e.printStackTrace（）;

}

System.out.println（“主线程存在”）;

```

如果我们运行前面的代码，结果将与基于扩展`Thread`类的线程运行相同。

# 扩展 Thread 与实现 Runnable

实现`Runnable`的优点（在某些情况下，也是唯一可能的选项）是允许实现扩展另一个类。当您想要向现有类添加类似线程的行为时，这是特别有帮助的。

```java

public class BRunnable extends SomeClass implements Runnable {

int i;

BRunnable(int i, String s) {

super(s);

this.i = i;

}

public int calculateSomething(double x) {

//计算结果

返回结果;

}

public void run() {

//您需要的任何代码都在这里

}

}

```

您甚至可以直接调用方法`run()`，而不将对象传递到 Thread 构造函数中：

```java

BRunnable obj = new BRunnable(2, "whatever");

int i = obj.calculateSomething(42d);

obj.run();

Thread thr = new Thread (obj);

thr.start();

```

在上面的代码片段中，我们展示了执行实现`Runnable`的类的方法的许多不同方式。因此，实现`Runnable`允许更灵活地使用。但是，与扩展`Thread`相比，在功能上没有区别。

`Thread`类有几个构造函数，允许设置线程名称和它所属的组。对线程进行分组有助于在许多线程并行运行的情况下对其进行管理。`Thread`类还有几种方法，提供有关线程状态和属性的信息，并允许我们控制其行为。

线程——以及任何对象——也可以使用基类`java.lang.Object`的`wait()`、`notify()`和`notifyAll()`方法相互通信。

但所有这些都已经超出了入门课程的范围。

# 如何执行 main(String[])方法

在深入讨论垃圾收集过程之前，我们想要回顾并总结如何从命令行运行应用程序。在 Java 中，以下语句用作同义词：

+   运行/执行主类

+   运行/执行/启动应用程序

+   运行/执行/启动主方法

+   运行/执行/启动/启动 JVM 或 Java 进程

这是因为列出的每个操作都会在执行其中一个操作时发生。还有几种方法可以做到这一点。我们已经向您展示了如何使用 IntelliJ IDEA 和`java`命令行运行`main(String[])`方法。现在，我们将重复已经说过的一些内容，并添加其他可能对您有帮助的变体。

# 使用 IDE

任何 IDE 都允许运行主方法。在 IntelliJ IDEA 中，有三种方法可以做到这一点：

+   通过单击方法名称旁边的绿色箭头

+   通过从下拉菜单中选择类名（在顶部行的左侧，绿色箭头的左侧）并单击菜单右侧的绿色箭头：

![](img/47ecc693-bded-4567-b5f6-2fea2f282d4b.png)

+   通过单击运行菜单并选择类的名称：

![](img/90dbb360-a4a9-435d-82de-6f2c4d56b72c.png)

在上面的截图中，您还可以看到选项“编辑配置”。我们已经使用它来设置可以在启动时传递给主方法的参数。但是还有更多的设置可能：

![](img/3a7dc463-e2f3-4594-9549-0f64f3460763.png)

正如您所看到的，还可以设置：

+   VM 选项：Java 命令选项（我们将在下一节中进行）

+   环境变量：设置一些参数，不仅可以在主方法中读取，还可以在应用程序的任何地方使用`System.getenv()`方法

例如，看看以下截图：

![](img/1e093c7a-d9fd-49ef-9bff-c3a8dd3b08fa.png)

我们已经设置了`java`命令选项`-Xlog:gc`和环境变量`myprop1=whatever`。IDE 将使用这些设置来形成以下`java`命令：

```java

java -Xlog:gc -Dmyprop1=whatever com.packt.javapath.ch04demo.MyApplication 2

```

选项`-Xlog:gc`告诉 JVM 显示来自垃圾回收过程的日志消息。我们将在下一节中使用此选项来演示垃圾回收的工作原理。可以使用以下语句在应用程序的任何位置检索变量`myprop1`的值：

```java

String myprop = System.getenv("myprop1");     //返回："whatever"

```

我们已经看到参数 2 如何在主方法中读取：

```java

public static void main(String[] args) {

String p1 = args[0];          //返回："2"

}

```

# 带有类路径上的类的命令行

让我们使用我们在第四章中创建的第一个程序，*Your First Java Project*，来演示如何使用命令行。以下是我们当时编写的程序：

```java

package com.packt.javapath.ch04demo;

import com.packt.javapath.ch04demo.math.SimpleMath;

public class MyApplication {

public static void main(String[] args) {

int i = Integer.parseInt(args[0]);

SimpleMath simpleMath = new SimpleMath();

int result = simpleMath.multiplyByTwo(i);

System.out.println(i + " * 2 = " + result);

}

}

```

要从命令行运行它，必须首先使用`javac`命令对其进行编译。使用 Maven 的 IDE 将`.class`文件放在目录`target/classes`中。如果进入项目的根目录或单击 Terminal（IntelliJ IDEA 左下角），可以运行以下命令：

```java

java -cp target/classes com.packt.javapath.ch04demo.MyApplication 2

```

结果应显示为`2 * 2 = 4`。

# 带有类路径上的.jar 文件的命令行

创建一个带有编译应用程序代码的`.jar`文件，转到项目根目录并运行以下命令：

```java

cd target/classes

jar -cf myapp.jar com/packt/javapath/ch04demo/**

```

创建了一个带有类`MyApplication`和`SimpleMath`的`.jar`文件。现在我们可以将其放在类路径上并再次运行应用程序：

```java

java -cp myapp.jar com.packt.javapath.ch04demo.MyApplication 2

```

结果将显示相同；`2 * 2 = 4`。

# 带有可执行.jar 文件的命令行

可以避免在命令行中指定主类。相反，可以创建一个“可执行”的`.jar`文件。可以通过将主类的名称（需要运行的类，包含主方法的类）放入清单文件中来实现。以下是步骤：

+   创建一个文本文件`manifest.txt`（实际名称并不重要，但它可以清楚地表达意图），其中包含以下一行：`Main-Class: com.packt.javapath.ch04demo.MyApplication`。冒号（`:`）后必须有一个空格，并且末尾必须有一个不可见的换行符号，因此请确保您按下了*Enter*键并且光标已跳转到下一行的开头。

+   执行命令`cd target/classes`并进入目录`classes`。

+   执行以下命令：`jar -cfm myapp.jar  manifest.txt  com/packt/javapath/ch04demo/**`。

注意`jar`命令选项`fm`的顺序和以下文件的顺序；`myapp.jar manifest.txt`。它们必须相同，因为`f`代表`jar`命令将要创建的文件，`m`代表清单源。如果将选项放置为`mf`，则文件必须列为`manifest.txt myapp.jar`。

现在，运行以下命令：

```java

java -jar  myapp.jar  2

```

结果将再次显示为`2 * 2 = 4`。

具备运行应用程序的知识后，我们现在可以继续到下一节，那里将需要它。

# 垃圾回收

自动内存管理是 JVM 的一个重要方面，它使程序员无需以编程方式进行内存管理。在 Java 中，清理内存并允许您重用它的过程称为**垃圾回收**（**GC**）。

# 响应性、吞吐量和停顿时间

垃圾收集的有效性影响着两个主要应用程序特征 - 响应性和吞吐量。响应性是指应用程序对请求的快速响应（提供必要数据）的度量。例如，网站返回页面的速度，或者桌面应用程序对事件的快速响应。响应时间越短，用户体验就越好。另一方面，吞吐量表示应用程序在单位时间内可以完成的工作量。例如，一个 Web 应用程序可以提供多少请求，或者一个数据库可以支持多少交易。数字越大，应用程序可能产生的价值就越大，可以支持的用户请求也就越多。

与此同时，垃圾收集器需要移动数据，这在允许数据处理的同时是不可能完成的，因为引用将会发生变化。这就是为什么垃圾收集器需要偶尔停止应用程序线程的执行一段时间，这段时间被称为停顿时间。这些停顿时间越长，垃圾收集器完成工作的速度就越快，应用程序冻结的时间也就越长，最终可能会足够大以至于影响应用程序的响应性和吞吐量。幸运的是，可以使用`java`命令选项来调整垃圾收集器的行为，但这超出了本书的范围，本书更多地是介绍而不是解决复杂问题。因此，我们将集中讨论垃圾收集器主要活动的高层视图；检查堆中的对象并删除那些在任何线程堆栈中没有引用的对象。

# 对象年龄和代

基本的垃圾收集算法确定了每个对象的年龄。年龄指的是对象存活的收集周期数。当 JVM 启动时，堆是空的，并被分为三个部分：年轻代、老年代或终身代，以及用于容纳大小为标准区域的 50%或更大的对象的巨大区域。

年轻代有三个区域，一个伊甸园空间和两个幸存者空间，如幸存者 0（*S0*）和幸存者 1（*S1*）。新创建的对象被放置在伊甸园中。当它填满时，会启动一个次要的垃圾收集过程。它会移除无引用和循环引用的对象，并将其他对象移动到*S1*区域。在下一次次要收集时，*S0*和*S1*会交换角色。引用对象会从伊甸园和*S1*移动到*S0*。

在每次次要收集时，已经达到一定年龄的对象会被移动到老年代。由于这个算法的结果，老年代包含了比一定年龄更老的对象。这个区域比年轻代要大，因此垃圾收集在这里更昂贵，不像在年轻代那样频繁。但最终会进行检查（经过几次次要收集）；无引用的对象将从那里删除，并且内存会被整理。这种老年代的清理被认为是一次主要收集。

# 当无法避免停顿时间时

老年代中的一些对象收集是并发进行的，而另一些则使用停顿时间进行。具体步骤包括：

+   对可能在老年代中引用对象的幸存者区域（根区域）进行初始标记，使用停顿时间进行

+   扫描幸存者区域以查找对老年代的引用，与此同时应用程序继续运行

+   并发标记整个堆中的活动对象，与此同时应用程序继续运行

+   标记 - 完成对活动对象的标记，使用停顿时间进行

+   清理 - 计算活动对象的年龄并释放区域（使用停顿时间），并将其返回到空闲列表（并发进行）

前面的序列可能会与年轻一代的疏散交错，因为大多数对象的生命周期很短，通过更频繁地扫描年轻一代来释放大量内存更容易。还有一个混合阶段（当 G1 收集已标记为大部分垃圾的区域，既在年轻一代又在旧一代）和巨大分配（将大对象移动到或从巨大区域疏散）。

为了演示 GC 的工作原理，让我们创建一个产生比我们通常的示例更多垃圾的程序：

```java

public class GarbageCollectionDemo {

public static void main(String... args) {

int max = 99888999;

List<Integer> list = new ArrayList<>();

for(int i = 1; i < max; i++){

list.add(Integer.valueOf(i));

}

}

}

```

此程序生成接近 100,000,000 个占用大量堆空间的对象，并迫使 GC 将它们从 Eden 移动到 S0、S1 等。正如我们已经提到的，要查看 GC 的日志消息，必须在`java`命令中包含选项`-Xlog:gc`。我们选择使用 IDE，正如我们在上一节中描述的那样：

![](img/c73265ab-f907-43e7-855d-8e04e98394a9.png)

然后，我们运行了程序`GarbageCollectionDemo`并得到了以下输出（我们只显示了其开头）：

![](img/173896b1-0e47-4fc2-ac88-4e8e33db9032.png)

正如您所看到的，GC 过程经过循环，并根据需要移动对象，暂停一小段时间。我们希望您了解了 GC 的工作原理。我们唯一想提到的是，在几个场合下会执行完全 GC，使用停止-世界暂停：

+   并发故障：如果在标记阶段旧一代变满。

+   **提升失败**：如果在混合阶段旧一代空间不足。

+   **疏散失败**：当收集器无法将对象提升到幸存者空间和旧一代时。

+   **巨大分配**：当应用程序尝试分配一个非常大的对象时。如果调整正确，您的应用程序应该避免完全 GC。

为了帮助 GC 调优，JVM 提供了平台相关的默认选择，用于垃圾收集器、堆大小和运行时编译器。但幸运的是，JVM 供应商一直在改进和调优 GC 过程，因此大多数应用程序都可以很好地使用默认的 GC 行为。

# 练习-在运行应用程序时监视 JVM

阅读 Java 官方文档，并命名几个随 JDK 安装提供的工具，可用于监视 JVM 和 Java 应用程序。

# 答案

例如 Jcmd、Java VisualVM 和 JConsole。Jcmd 特别有帮助，因为它易于记忆，并为您列出当前正在运行的所有 Java 进程。只需在终端窗口中键入`jcmd`。这是一个不可或缺的工具，因为您可能正在尝试运行几个 Java 应用程序，其中一些可能因为缺陷或故意设计而无法退出。Jcmd 为每个正在运行的 Java 进程显示一个**进程 ID**（**PID**），您可以使用该 ID 通过键入命令`kill -9 <PID>`来停止它。

# 摘要

在本章中，您已经了解了支持任何应用程序执行的主要 Java 进程，程序执行的步骤以及组成执行环境的 JVM 架构的主要组件；运行时数据区域，类加载器和执行引擎。您还了解了称为线程的轻量级进程以及它们如何用于并发处理。有关运行 Java 应用程序的方法总结以及垃圾收集过程的主要特点结束了有关 JVM 的讨论。

在下一章中，我们将介绍几个经常使用的库-标准库（随 JDK 一起提供）和外部开源库。很快，您将非常了解它们中的大部分，但要到达那里，您需要开始，我们将在评论和示例中帮助您。
