<html><head></head><body>
        

                            
                    <h1 class="header-title">Packages and Accessibility (Visibility)</h1>
                
            
            
                
<p>By now, you are already quite familiar with packages. In this chapter, we will complete its description and then discuss different levels of accessibility (also called visibility) of classes and class members – methods and fields. It all will come down to the key concept of object-oriented programming – the encapsulation – and lay the foundation for our discussion of object-oriented design principles.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>What is importing?</li>
<li>Static importing</li>
<li>Interface access modifiers</li>
<li>Class access modifiers</li>
<li>Method access modifiers</li>
<li>Property access modifiers</li>
<li>Encapsulation</li>
<li>Exercise – Shadowing</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What is importing?</h1>
                
            
            
                
<p>Importing allows us to specify a fully qualified class or interface name only once at the beginning of the <kbd>.java</kbd> file, before the class or interface declaration. The format of an import statement is as follows:</p>
<pre>import &lt;package&gt;.&lt;class or interface name&gt;;</pre>
<p>For example, look at the following:</p>
<pre>import com.packt.javapath.ch04demo.MyApplication;</pre>
<p>From now on, this class can be referred to in the code by its name, <kbd>MyApplication</kbd>, only. It is also possible to import all the classes or interfaces of a package using the wildcard character (<kbd>*</kbd>):</p>
<pre>import com.packt.javapath.ch04demo.*;</pre>
<p>Notice that the preceding import statement imports classes and interfaces of the subpackages of the <kbd>com.packt.javapath.ch04demo</kbd> package. If needed, each subpackage has to be imported separately.</p>
<p>But, before we continue, let's talk about the <kbd>.java</kbd> file structure and packages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Structure of the .java file and packages</h1>
                
            
            
                
<p>As you already know, the package name reflects the directory structure, starting with the project directory that contains the <kbd>.java</kbd> files. The name of each <kbd>.java</kbd> file has to be the same as the name of the public class defined in it. The first line of the <kbd>.java</kbd> file is the package statement that starts with the <kbd>package</kbd> keyword, followed by the actual package name—the directory path to this file, in which slashes are replaced with dots. Let's look at some examples. We will look primarily at the <kbd>.java</kbd> file that contains a class definition, but we will also look at files with interfaces and the <kbd>enum</kbd> class definition because there is a particular type of importing (called static importing) that is primarily used with interfaces and <kbd>enum</kbd>.</p>
<p>We assume that the <kbd>src/main/java</kbd> (for Linux) or <kbd>src\main\java</kbd> (for Windows) project directory contains all the <kbd>.java</kbd> files, and the definition of the <kbd>MyClass</kbd> and <kbd>MyEnum</kbd> classes and the <kbd>MyInterface</kbd> interface from the package <kbd>com.packt.javapath</kbd> are stored in the files: </p>
<pre>src/main/java/com/packt/javapath/MyClass.java (for Linux) <br/>src/main/java/com/packt/javapath/MyEnum.java<br/>src/main/java/com/packt/javapath/MyInterface.java </pre>
<p>or (for Windows)</p>
<pre>src\main\java\com\packt\javapath\MyClass.java (for Windows) <br/>src\main\java\com\packt\javapath\MyEnum.java<br/>src\main\java\com\packt\javapath\MyInterface.java </pre>
<p>The first line of each of these files is as follows:</p>
<pre>package com.packt.javapath;</pre>
<p>If we do not import anything, then the next line in each file is a class or interface declaration.</p>
<p>The declaration of the <kbd>MyClass</kbd> class looks like this:</p>
<pre>public class MyClass extends SomeClass <br/>     implements Interface1, Interface2, ... {...}</pre>
<p>It consists of the following:</p>
<ul>
<li>An access modifier; one of the classes in the file has to be <kbd>public</kbd></li>
<li>The <kbd>class</kbd> keyword</li>
<li>The class name (identifier) that starts with a capital letter by convention</li>
<li>If the class is a child of another class, the <kbd>extends</kbd> keyword and the name of the parent class</li>
<li>If the class implements one or more interfaces, the <kbd>implements</kbd> keyword followed by the comma-separated list of interfaces it implements</li>
<li>The body of the class (where the fields and methods are defined) surrounded by braces, <kbd>{}</kbd></li>
</ul>
<p>The declaration of the <kbd>MyEnum</kbd> class looks like this:</p>
<pre>public enum MyEnum implements Interface1, Interface2, ... {...}</pre>
<p>It consists of the following:</p>
<ul>
<li>An access modifier; it has to be <kbd>public</kbd> if it is the only class defined in the file</li>
<li>The <kbd>enum</kbd> keyword</li>
<li>The class name (identifier) that starts with a capital letter by convention</li>
<li>No <kbd>extends</kbd> keyword because the enum type extends the <kbd>java.lang.Enum</kbd> class implicitly and, in Java, a class can have only one parent</li>
<li>If the class implements one or more interfaces, the <kbd>implements</kbd> keyword followed by the comma-separated list of interfaces it implements</li>
<li>The body of the class (where the constants and methods are defined) surrounded by braces, <kbd>{}</kbd></li>
</ul>
<p>The declaration of the <kbd>MyInterface</kbd> interface looks like this:</p>
<pre>public interface MyInterface extends Interface1, Interface2, ... {...}</pre>
<p>It consists of the following:</p>
<ul>
<li>An access modifier; one of the interfaces in the file has to be <kbd>public</kbd></li>
<li>The <kbd>interface</kbd> keyword</li>
<li>The interface name (identifier) that starts with a capital letter by convention</li>
<li>If the interface is a child of one or more interfaces, the <kbd>extends</kbd> keyword followed by the comma-separated list of the parent interfaces</li>
<li>The body of the interface (where the fields and methods are defined) surrounded by braces, <kbd>{}</kbd></li>
</ul>
<p>Without importing, we would need to refer to each class or interface we are using by its fully qualified name, which includes the package name and class, or interface name. For example, the <kbd>MyClass</kbd> class declaration would look like this:</p>
<pre>public class MyClass <br/>          extends com.packt.javapath.something.AnotherMyClass <br/>          implements com.packt.javapath.something2.Interface1,<br/>                     com.packt.javapath.something3.Interface2</pre>
<p>Or, let's say we would like to instantiate the <kbd>SomeClass</kbd> class from the <kbd>com.packt.javapath.something</kbd> package. The fully qualified name of that class would be <kbd>com.packt.javapath.something.SomeClass</kbd> and its object creation statement would look as follows:</p>
<pre>com.packt.javapath.something.SomeClass someClass =<br/>                    new com.packt.javapath.something.SomeClass();</pre>
<p>It is too verbose, isn't it? This is where package importing comes to the rescue. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Single class import</h1>
                
            
            
                
<p>To avoid using the fully qualified class or interface name in the code, we can add an import statement in the space between the package declaration and class or interface declaration:</p>
<pre>package com.packt.javapath;<br/>import com.packt.javapath.something.SomeClass;<br/>public class MyClass {<br/>  //... <br/>  SomeClass someClass = new SomeClass();<br/>  //...<br/>}</pre>
<p>As you can see, the import statement allows avoiding usage of the fully qualified class name, which makes the code easier to read. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multiple classes import</h1>
                
            
            
                
<p>If several classes or interfaces from the same package are imported, it is possible to import all the package members using the asterisk (<kbd>*</kbd>) wildcard character.</p>
<p>If <kbd>SomeClass</kbd> and <kbd>SomeOtherClass</kbd> belong to the same package, then the import statement may look like this:</p>
<pre>package com.packt.javapath;<br/>import com.packt.javapath.something.*;<br/>public class MyClass {<br/>  //... <br/>  SomeClass someClass = new SomeClass();<br/>  SomeOtherClass someClass1 = new SomeOtherClass();<br/>  //...<br/>}</pre>
<p>The advantage of using the asterisk is a shorter list of import statements, but such a style hides the names of the imported classes and interfaces. So, the programmer may not know exactly where they come from. Besides, when two or more packages contain members with the same name, you just have to import them explicitly as a single class import. Otherwise, the compiler will generate an error.</p>
<p>On the other hand, the programmers who prefer wildcard importing, argue that it helps to prevent accidentally creating a class with a name that exists already in one of the imported packages. So, you have to make your own choice when it comes to style and configuring your IDE to use or not use the wildcard importing.</p>
<p>In IntelliJ IDEA, the default style of import is using a wildcard. If you would like to switch to a single class import, click on File | Other Settings | Default Settings, as in the following screenshot:</p>
<div><img class="aligncenter size-full wp-image-1512 image-border" src="img/15e4c441-99b0-4266-b669-26820d240037.png" style="width:31.75em;height:11.67em;"/></div>
<p>On the screen that opens, select Editor | Java and check the Use single class import checkbox:</p>
<div><img class="aligncenter size-full wp-image-1513 image-border" src="img/7dbd6160-11da-4075-afe8-394c3b78582c.png" style="width:32.08em;height:12.92em;"/></div>
<p>There are other settings on this page that you might find useful, so try to remember how to access it.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Static import</h1>
                
            
            
                
<p>Static import allows importing not just a class or an interface but its public members—fields and methods—individually. If you look in one of our test classes, you will see the following static import statement:</p>
<pre>import static org.junit.jupiter.api.Assertions.*;<br/></pre>
<p>This statement allowed us to write the following:</p>
<pre>Person p = new Person("Joe", "Blow", dob);<br/>assertTrue(p.equals(p));<br/></pre>
<p>That is instead of writing this:</p>
<pre>Person p = new Person("Joe", "Blow", dob);<br/>Assertions.assertTrue(p.equals(p));<br/></pre>
<p>That is one widespread case of static import usage. Another popular case is static importing of constants of an interface or <kbd>enum</kbd>. For example, if we have an interface as follows:</p>
<pre>package com.packt.javapath.api;<br/>public interface Constants {<br/>  String NAME = "name";<br/>}</pre>
<p>Then, to use its constants, one can import them statically:</p>
<pre>package com.packt.javapath;<br/>import static com.packt.javapath.api.Constants.*;<br/>public class MyClass {<br/>  //...<br/>  String s = "My " + NAME + " is Joe";<br/>  System.out.println(s);        //Prints: My name is Joe<br/>  //...<br/>} </pre>
<p>By the way, the same effect could be achieved by importing that <kbd>Constants</kbd> interface non-statically and having the class implement it:</p>
<pre>package com.packt.javapath;<br/>import com.packt.javapath.api.Constants;<br/>public class MyClass <strong>implements</strong> Constants {<br/>  //...<br/>  String s = "My " + NAME + " is Joe";<br/>  System.out.println(s);        //Prints: My name is Joe<br/>  //...<br/>} </pre>
<p>This style of implementing an interface in order to use their constants is quite popular among Java programmers.</p>
<p>An example of using static import in order to use the <kbd>enum</kbd> constants looks similar:</p>
<pre>import static java.time.DayOfWeek.*;</pre>
<p>It allows the code to use <kbd>DayOfWeek</kbd> constants as <kbd>MONDAY</kbd>, instead of <kbd>DayOfWeek.MONDAY</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Access modifiers</h1>
                
            
            
                
<p>There are three explicit access modifiers—public, private, and protected—and one implicit (default) access modifier that is implied when no access modifier is set. They can be applied to the top-level class or interface, their members, and constructors. A <em>top-level</em> class or interface can include a <em>member</em> class or interface. Other <em>members</em> of a class or interface are fields and methods. Classes also have <em>constructors</em>.</p>
<p>To demonstrate the accessibility, let's create a <kbd>com.packt.javapath.Ch07demo.pack01</kbd> package that contains two classes and two interfaces:</p>
<pre>public class PublicClass01 {<br/>  public static void main(String[] args){<br/>    //We will write code here<br/>  }<br/>}<br/><br/>class DefaultAccessClass01 {<br/>}<br/><br/>public interface PublicInterface01 {<br/>  String name = "PublicInterface01";<br/>}<br/> <br/>interface DefaultAccessInterface01 {<br/>  String name = "DefaultAccessInterface01";<br/>}</pre>
<p>We will also create another <kbd>com.packt.javapath.Ch07demo.pack02</kbd> package with one class in it:</p>
<pre>public class PublicClass02 {<br/>  public static void main(String[] args){<br/>    //We will write code here<br/>  }<br/>}</pre>
<p>Each of the preceding classes and interfaces is in its own file:</p>
<div><img class="aligncenter size-full wp-image-1514 image-border" src="img/eac9098f-e718-4bd2-ab43-b02aac7aa66e.png" style="width:32.25em;height:22.33em;"/></div>
<p>Now we are ready to explore the accessibility of classes, interfaces, their members, and constructors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The accessibility of a top-level class or interface</h1>
                
            
            
                
<p>The public class or interface is accessible from anywhere. We can import them and access them from another package:</p>
<pre>import com.packt.javapath.Ch07demo.pack01.PublicClass01;<br/>import com.packt.javapath.Ch07demo.pack01.PublicInterface01;<br/>//import com.packt.javapath.Ch07demo.pack01.DefaultAccessClass01;<br/>//import com.packt.javapath.Ch07demo.pack01.DefaultAccessInterface01;<br/><br/>public class PublicClass02 {<br/>  public static void main(String[] args){<br/>    System.out.println(PublicInterface01.name);<br/>    PublicClass01 o = new PublicClass01();<br/><br/>  }<br/>}</pre>
<p>In the preceding code, the two import statements are commented out because they generate an error. That is because in the <kbd>DefaultAccessClass01</kbd> class and the <kbd>DefaultAccessClass01</kbd> interface, we did not use the access modifier, which made them accessible only to the members of the same package. </p>
<p>Without an access modifier, a top-level class or interface can be accessed only by the members of the same package.</p>
<p>Making an access modifier <kbd>private</kbd> in the declaration of a top-level class or interface make them inaccessible, so using a <kbd>private</kbd> access modifier for a top-level class or interface does not make sense.</p>
<p>The <kbd>protected</kbd> keyword cannot be applied to a top level. This limitation is not as obvious. We will see in the next section that <kbd>protected</kbd> means it is accessible to the package members and the children. So, one could argue that <kbd>protected</kbd> access can be applicable to a top-level class or interface too. Yet, the Java authors decided not to do it, and the compiler will generate an exception if you try to make a top-level class or interface <kbd>protected</kbd>.</p>
<p>However, <kbd>private</kbd> and <kbd>protected</kbd> access modifiers can be applied to inner classes or interfaces—the members of the top-level class or interface. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Access to class or interface members</h1>
                
            
            
                
<p>Even when class or interface members are declared public, they cannot be accessed if the enclosing class or interface is inaccessible. So, all of the following discussion will be done under the assumption that the class or interface is accessible.</p>
<p>Members of a class or interface can access other members of the same class or interface no matter what access modifiers they have. Which makes sense, doesn't it? It all happens inside the same enclosing class or interface.</p>
<p>By default, the interface members are public. So, if an interface itself can be accessed, its members without access modifier can be accessed too. And, just to remind you, the interface fields are static and final (constants) by default.</p>
<p>The class members, on the other hand, without an access modifier, are accessible only to the package members. So, the class or interface may be public, but their members are less accessible, if not made public explicitly.</p>
<p>Private class or interface members are accessible only to the other members of the same class or interface. That is the most restricted access possible. Even children of the class cannot access their parents' private members.</p>
<p>Protected package members are accessible to other members of the same package and to the children of the class or interface, which means that protected members can be overridden. And that is often used by programmers as an expression of the intent: they make those members protected that they expect to be overridden. Otherwise, they make them either private or public. Default—no access modifiers—access is rarely used.</p>
<div><strong>Private</strong>: Allows access from the same class (or interface) only<br/>
<strong>No modifier (default)</strong>: Allows access from the same class (or interface) and the same package<br/>
<strong>Protected</strong>: Allows access from the same class (or interface), the same package, and any child<br/>
<strong>Public</strong>: Allows access from anywhere</div>
<p>The same accessibility rules apply to inner classes and interfaces too. Here is an example of a class that contains inner classes and interfaces:</p>
<pre>public class PublicClass01 {<br/>  public static void main(String[] args){<br/>    System.out.println(DefaultAccessInterface01.name);<br/>    DefaultAccessClass01 o = new DefaultAccessClass01();<br/>  }<br/>  class DefaultAccessClass{<br/>  }<br/>  protected class ProtectedClass{<br/>  }<br/>  private class PrivateClass{<br/>  }<br/>  interface DefaultAccessInterface {<br/>  }<br/>  protected class ProtectedInterface{<br/>  }<br/>  private class PrivateInterface{<br/>  }<br/>}</pre>
<p>And here is an interface with an inner class and interface: </p>
<pre>public interface PublicInterface01 {<br/>  String name = "PublicInterface01";
<br/>  class DefaultAccessClass{<br/>  }<br/>  interface DefaultAccessInterface {<br/>  }<br/>}</pre>
<p>As you can see, only default (public) access is allowed for the inner classes and interfaces of an interface.</p>
<p>And, just to repeat what we have already discussed, we will briefly mention some other related aspects of members accessibility:</p>
<ul>
<li>A static nested class (it is an inner class, but is called nested in the case of the static class by convention) cannot access non-static members of the same class, while they can access it</li>
<li>Being a member of some top-level class, a static nested class can be public, protected, package-accessible (default), or private</li>
<li>Public, protected, and package-accessible members of a class are inherited by the child</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The constructor's accessibility is the same as any class member</h1>
                
            
            
                
<p>As the title of this section has stated, that is all we can say about the accessibility of a constructor. Naturally, when we talk about constructors, we talk only about classes.</p>
<p>The interesting thing about constructors is their ability to have private access only. It means that a class can provide its own factory method (see <a href="6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml">Chapter 6</a>, <em>Interfaces, Classes, and Object Construction</em>), control how each object is constructed, and even control how many of them can be put into the circulation. The last feature is especially valuable in the case where each object requires access to a certain resource (a file or another database) that has limited support for concurrent access. Here is how the simplest version of such a factory method with a limited number of objects created may look:</p>
<pre>private String field;<br/>private static int count;<br/>private PublicClass02(String s){<br/>  this.field = s;<br/>}<br/>public static PublicClass02 getInstance(String s){<br/>  if(count &gt; 5){<br/>    return null;<br/>  } else {<br/>    count++;<br/>    return new PublicClass02(s);<br/>  }<br/>}</pre>
<p>The usefulness of this code is not great and we show it only to demonstrate how a privately accessible constructor can be used. It is possible because each class members can access all other class members no matter their access modifiers.</p>
<p>All the accessibility-related features would be not needed unless they brought some advantages. And that is what we are going to talk about in the next section – about the central concept of object-oriented programming, called encapsulation, which would be impossible without accessibility control. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Encapsulation</h1>
                
            
            
                
<p>The concept of OOP was born in an effort to manage the increasing complexity of software systems. The concept of data and procedures bundled in an object with controlled access to them (called encapsulation) allows better-organized data and procedures in layers, some of them hidden, others exposed to an access from outside. The accessibility control described in the previous sections was a significant part of it. Together with inheritance, interface (also called abstraction), and polymorphism, encapsulation became one of the central concepts of OOP.  </p>
<p>There is often no clear-cut separation of one OOP concept from another. Interfaces help to hide (encapsulate) the implementation details too. Inheritance, with its ability to override and hide methods of the parent classes, adds a dynamic aspect to the accessibility. All these three concepts make it possible to add the concept of polymorphism—the ability of the same object to present itself as a different type, depending on the context (based on inheritance or an implemented interface), or change its behavior based on the data availability (using composition—we will talk about it in <a href="2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml">Chapter 8</a>, <em>Object-Oriented Design (OOD) Principles—</em>or method overloading, hiding, and overriding). </p>
<p>But none of the concepts would be possible without encapsulation. That is why it is the most fundamental among the four concepts of OOP. Chances are, you will hear it mentioned a lot, so we have decided to dedicate this section to the terms often used in the context of an encapsulation based on the advantages it provides:</p>
<ul>
<li>Data hiding and decoupling</li>
<li>Flexibility, maintainability, refactoring</li>
<li>Reusability</li>
<li>Testability</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Data hiding and decoupling</h1>
                
            
            
                
<p>When we make object states (values of its fields) and some methods private or impose some other measure of restricted access to the internal object data, we participate in <em>data hiding</em>. The user of the object's functionality can call only certain methods based on their accessibility and cannot manipulate the object's internal state directly. The object's users may have no idea how exactly the functionality is implemented and the data is stored. They pass the required input data to the accessible methods and get back the results. This way we <em>decouple</em> the internal state from its usage and the implementation details from the API.</p>
<p>Grouping related methods and data in the same class also increases <em>decoupling</em>, this time between different areas of functionality.</p>
<p>You may hear the term <em>tightly coupled</em> as something that should be allowed only when there is no way to avoid it because it usually means that any change of one part would require a corresponding change of another part. Even in everyday life, we prefer to deal with modularized systems that allow replacing one module only without changing any other component of the rest of the system.</p>
<p>That is why <em>loose coupling</em> is usually something programmers prefer although it often comes at the price of not being sure that there will be no unexpected surprises until the system is tested in all possible execution paths. A well-thought-out system of tests that cover the essential use cases usually helps to reduce the chance of a defect propagation in production.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Flexibility, maintainability, and refactoring</h1>
                
            
            
                
<p>When we talked about decoupling in the previous section, the idea of flexibility and maintainability probably came to mind by association. Loosely coupled systems are more flexible and easier to maintain.</p>
<p>For example, in <a href="6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml">Chapter 6</a>, <em>Interfaces, Classes, and Object Construction</em>, we demonstrated a flexible solution when implementing an object factory:</p>
<pre>public static Calculator createInstance(){<br/>  WhichImpl whichImpl = <br/>      Utils.getWhichImplValueFromConfig(Utils.class,<br/>            Calculator.CONF_NAME, Calculator.CONF_WHICH_IMPL);<br/>  switch (whichImpl){<br/>    case multiplies:<br/>      return new CalculatorImpl();<br/>    case adds:<br/>      return new AnotherCalculatorImpl();<br/>    default:<br/>      throw new RuntimeException("Houston, we have another problem."+<br/>                  " We do not have implementation for the key " +<br/>                  Calculator.CONF_WHICH_IMPL + " value " + whichImpl);<br/>    }<br/>}</pre>
<p>It is tightly coupled with its <kbd>Calculator</kbd> interface (its API) only, but that is inevitable because it is the contract the implementation must honor. As for the implementation inside the factory, it is much freer from any restrictions as long as it adheres to the contract. </p>
<p>We could create an instance of each of the implementations only once and return only that one instance (making each class a singleton). Here is an example of <kbd>CalculatorImpl</kbd> as a singleton:</p>
<pre>private static Calculator calculator = null;<br/>public static Calculator createInstance(){<br/>  WhichImpl whichImpl = <br/>      Utils.getWhichImplValueFromConfig(Utils.class,<br/>            Calculator.CONF_NAME, Calculator.CONF_WHICH_IMPL);<br/>  switch (whichImpl){<br/>    case multiplies:<br/>      if(calculator == null){<br/>        calculator = new CalculatorImpl();<br/>      }<br/>      return calculator;<br/>    case adds:<br/>      return new AnotherCalculatorImpl();<br/>    default:<br/>      throw new RuntimeException("Houston, we have another problem."+<br/>                      " We do not have implementation for the key " +<br/>                  Calculator.CONF_WHICH_IMPL + " value " + whichImpl);<br/>    }<br/>}</pre>
<p>Or we could add another <kbd>Calculator</kbd> implementation to the factory as a nested class and use it instead of <kbd>CalculatorImpl</kbd>:</p>
<pre>public static Calculator createInstance(){<br/>  String whichImpl = Utils.getStringValueFromConfig(CalculatorFactory.class,<br/>            "calculator.conf", "which.impl");<br/>  if(whichImpl.equals("multiplies")){<br/>    return new Whatever();<br/>  } else if (whichImpl.equals("adds")){<br/>    return new AnotherCalculatorImpl();<br/>  } else {<br/>    throw new RuntimeException("Houston, we have a problem. " +<br/>              "Unknown key which.impl value " + whichImpl +<br/>              " is in config.");<br/>  }<br/><br/>}<br/><br/>static class Whatever implements Calculator {<br/>  public static String addOneAndConvertToString(double d){<br/>    System.out.println(Whatever.class.getName());<br/>    return Double.toString(d + 1);<br/>  }<br/>  public int multiplyByTwo(int i){<br/>    System.out.println(Whatever.class.getName());<br/>    return i * 2;<br/>  }<br/>}</pre>
<p>And the client code of this factory would never know the difference unless it prints out information about the class using the <kbd>getClass()</kbd> method on the object returned from the factory. But that is another story. Functionally, our new implementation of <kbd>Whatever</kbd> would work as an old one.</p>
<p>And that is actually a common practice—to change internal implementation from one release to another. There are bug fixes, of course, and new functionality added. And as the code of the implementation is evolving, its programmers are constantly watching for the possibility of refactoring. In computer science, factoring is a synonym of decomposition, which is breaking a complex code into simpler parts with the purpose of making the code more readable and maintainable. For example, let's assume we were asked to write a method that accepts two parameters of the <kbd>String</kbd> type (each represents an integer) and returns their sum as an integer too. After thinking for a moment, we decided to do it this way:</p>
<pre>public long sum(String s1, String s2){<br/>  int i1 = Integer.parseInt(s1);<br/>  int i2 = Integer.parseInt(s1);<br/>  return i1 + i2;<br/>}</pre>
<p>But then we have asked for a sample of possible input values, so we can test our code in the condition close to production. It turned out that some of the values can be up to 10,000,000,000, which exceeds 2,147,483,647 (the maximum <kbd>Integer.MAX_VALUE</kbd> int value Java allows). So we have changed our code to the following:</p>
<pre>public long sum(String s1, String s2){<br/>  long l1 = Long.parseLong(s1);<br/>  long l2 = Long.parseLong(s2);<br/>  return l1 + l2;<br/>}</pre>
<p>Now our code can handle values up to 9,223,372,036,854,775,807 (which is <kbd>Long.MAX_VALUE</kbd>). We deployed the code to production and it worked just fine for several months, used by a big software system that processes statistics. Then the system switched to a new source of data and the code started breaking. We investigated and found out that a new source of data yields values that can include letters and some other characters. We have tested our code for such cases and discovered that the following line throws <kbd>NumberFormatException</kbd>:</p>
<pre>long l1 = Long.parseLong(s1);<br/></pre>
<p>We discussed the situation with the domain experts and they suggested we record the values that are not integer, skip them, and continue the sum calculations. So, we have fixed our code, as follows:</p>
<pre>public long sum(String s1, String s2){<br/>  long l1 = 0;<br/>  try{<br/>    l1 = Long.parseLong(s1);<br/>  } catch (NumberFormatException ex){<br/>    //make a record to a log<br/>  }<br/>  long l2 = 0;<br/>  try{<br/>    l2 = Long.parseLong(s2);<br/>  } catch (NumberFormatException ex){<br/>    //make a record to a log<br/>  }<br/>  return l1 + l2;<br/>}</pre>
<p>We have quickly released the code to production, but for the next release got new requirements: the input <kbd>String</kbd> values can contain decimal numbers. So, we have changed the way we process the input <kbd>String</kbd> values by assuming they carry decimal values (which cover integer values too) and refactored the code, as follows:</p>
<pre>private long getLong(String s){<br/>  double d = 0;<br/>  try{<br/>    d = Double.parseDouble(s);<br/>  } catch (NumberFormatException ex){<br/>    //make a record to a log<br/>  }<br/>  return Math.round(d);<br/>}<br/>public long sum(String s1, String s2){<br/>  return getLong(s1) + getLong(s2);<br/>}</pre>
<p>That is what refactoring does. It restructures the code without changing its API. As new requirements keep coming in, we can change the <kbd>getLong()</kbd> method without even touching the <kbd>sum()</kbd> method. We also can reuse the <kbd>getLong()</kbd> method in other places, and that is going to be the topic of the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reusability</h1>
                
            
            
                
<p>Encapsulation definitely makes it easier to achieve reusability because it hides the implementation details. For example, the <kbd>getLong()</kbd> method we wrote in the previous section can be reused by another method of the same class:</p>
<pre>public long sum(int i, String s2){<br/>  return i + getLong(s2);<br/>}</pre>
<p>It can even be made public and used by other classes, like in the following line:</p>
<pre>int i = new Ch07DemoApp().getLong("23", "45.6");</pre>
<p>That would be an example of a composition when some functionality is built (composed) using methods of different classes not related by inheritance. And, since it does not depend on the object state (such a method is called stateless), it can be made static:</p>
<pre>int i = Ch07DemoApp.getLong("23", "45.6");</pre>
<p>Well, if the method is used concurrently by several other methods at runtime, even such a simple code may need to be protected (synchronized) against parallel usage. But such considerations are outside of the scope of this book. For now, if in doubt, do not make the method static. </p>
<p>If you read about the history of object-oriented programming, you will find that inheritance was originally tasked, among other things, to be the primary mechanism of code reuse. And it does the job. A child inherits (reuses) all the methods of its parent and overrides only those that need to be overridden for the child's specialization.</p>
<p>But in practice, it seems that other reusability techniques, similar to those demonstrated earlier, are more popular, especially for cases when the reused method is stateless. We will talk more about the reasons for that in <a href="2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml">Chapter 8</a>, <em>Object-Oriented Design (OOD) Principles</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testability</h1>
                
            
            
                
<p>Code testability is another area where encapsulation helps. If the implementation details were not hidden, we would need to test every single line of code and change the test every time we change any line of the implementation. But hiding the details behind the facade of the API allows us to focus only on the test cases that are required and limited by the set of possible input data (parameter values). </p>
<p>Also, there are frameworks that allow us to create an object that returns a certain result based on the certain value of the input parameters. Mockito is a popular framework that does it (<a href="http://site.mockito.org">http://site.mockito.org</a>). Such objects are called mock objects. They are especially helpful when you need to get certain results from methods of one object to test other methods, but you cannot run the actual implementation of the methods you use as the source of data because you do not have the necessary data in the database, for example, or it requires some complicated setup. To get around the problem, you can replace the actual implementation of certain methods—mock them—with one that returns the data you need unconditionally or in response to certain input data. Without the encapsulation, such simulation of a method behavior may be impossible because the client code would be tied to the specific implementation and you would not be able to change it without changing the client code.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercise – Shadowing</h1>
                
            
            
                
<p>Write the code that demonstrates variable shadowing. We have not talked about it, so you will need to do some research.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Answer</h1>
                
            
            
                
<p>Here is one possible solution:</p>
<pre>public class ShadowingDemo {<br/>  private String x = "x";<br/>  public void printX(){<br/>    System.out.println(x);   <br/>    String x = "y";<br/>    System.out.println(x);   <br/>  }<br/>}</pre>
<p>If you run <kbd>new ShadowingDemo().printX();</kbd>, it will print <kbd>x</kbd> first, then <kbd>y</kbd> because the local variable <kbd>x</kbd> in the following line shadows the <kbd>x</kbd> instance variable:</p>
<pre>String x = "y";<br/></pre>
<p>Please note that shadowing can be a source of a defect or can be used for the benefit of the program. Without it, you would be not able to use a local variable identifier that is already used by an instance variable. And here is another example of a case where variable shadowing helps:</p>
<pre>private String x = "x";<br/>public void setX(String x) {<br/>  this.x = x;<br/>}</pre>
<p>The <kbd>x</kbd> local variable (parameter) shadows the <kbd>x</kbd> instance variable. It allows using the same identificator for a local variable name that has been already used for an instance variable name. To avoid possible confusion, it is recommended to refer to an instance variable using the keyword <kbd>this</kbd> as we did in the example above.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you learned about one of the fundamental features of an object-oriented language – the rules of accessibility of classes, interfaces, their members, and constructors. You now can import classes and interfaces from other packages and avoid using their fully qualified names. All that discussion allowed us to introduce the central concept of OOP—encapsulation. With that, we can start an informed discussion of <strong>object-oriented design</strong> (<strong>OOD</strong>) principles.</p>
<p>The next chapter presents a higher-level view of Java programming. It discusses the criteria of a good design and provides a guide to the well-proven OOD principles. Each of the design principles is described in detail and illustrated using a corresponding code example.</p>


            

            
        
    </body></html>