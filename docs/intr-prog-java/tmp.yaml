- en: There is one last very important term related to interfaces. A method signature
    listed in the interface without an implementation is called an **abstract method** and
    the interface itself is called **abstraction** because it abstracts, summarizes,
    and removes the signatures from the implementation. An abstraction cannot be instantiated.
    As an example, if you put the keyword `abstract` in front of any class and try
    to create its object, the compiler will throw an error even if all the methods
    in the class are not abstract. In such a case, the class behaves as an interface
    with the default methods only. Yet, there is a significant difference in their
    usage, which you will see after reading the upcoming *Inheritance* section of
    this chapter.
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 与接口相关的最后一个非常重要的术语是抽象方法。接口中列出的没有实现的方法签名称为**抽象方法**，接口本身称为**抽象**，因为它抽象化、总结并移除了实现中的方法签名。抽象不能被实例化。例如，如果在任何类前面放置关键字`abstract`并尝试创建其对象，即使类中的所有方法都不是抽象的，编译器也会抛出错误。在这种情况下，类仅作为具有默认方法的接口。然而，在它们的使用上有显著的区别，您将在本章的接下来的*继承*部分中看到。
- en: We will talk more about interfaces in Chapter 6, *Interfaces, Classes, and Objects
    Construction*, and cover their access modifiers in Chapter 7, *Packages and Accessibility
    (Visibility)*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第6章*接口，类和对象构建*中更多地讨论接口，并在第7章*包和可访问性（可见性）*中涵盖它们的访问修饰符。
- en: Implementation
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'An interface can be implemented by a class, which means that the class has
    a body for each of the abstract methods listed in the interface. Here is an example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接口可以被类实现，这意味着该类为接口中列出的每个抽象方法提供了一个具体的实现。这里是一个例子：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We named the class `CarImpl` to indicate that it is an implementation of the
    interface `Car`. But we could name it any other way we like.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将类命名为`CarImpl`，表示它是接口`Car`的实现。但是我们可以随意为其命名。
- en: 'Both interface and its class implementation can have other methods too without
    causing a compiler error. The only requirement for the extra method in the interface
    is that it has to be default and have a body. Adding any other method to a class
    does not interfere with the interface implementation.  For example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 接口及其类实现也可以有其他方法，而不会引起编译错误。接口中额外方法的唯一要求是必须是默认方法并有具体实现。向类添加任何其他方法都不会干扰接口实现。例如：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we now create an instance of a class `CarImpl`, we can call all the methods
    we have declared in the class:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在创建一个`CarImpl`类的实例，我们可以调用类中声明的所有方法：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That was not surprising.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不令人惊讶。
- en: 'But, here is something you might not have expected:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这里有一些你可能意想不到的：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This means that by implementing an interface class acquires all the default
    methods the interface has. That is the purpose of the default methods: to add
    functionality to all classes that implement the interface. Without it, if we add
    an abstract method to an old interface, all current interface implementations
    will trigger a compiler error. But, if we add a new method with the modifier default,
    the existing implementations will continue working as usual.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着通过实现一个接口，类获得了接口默认方法。这就是默认方法的目的：为实现接口的所有类添加功能。如果没有默认方法，如果向旧接口添加一个抽象方法，所有当前的接口实现将触发编译错误。但是，如果添加一个带有`default`修饰符的新方法，现有的实现将继续像往常一样工作。
- en: 'Now, another nice trick. If a class implements a method with the same signature
    as the default method, it will `override` (a technical term) the behavior of the
    interface. Here is an example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，另一个很好的技巧。如果一个类实现了与默认方法相同签名的方法，它将`覆盖`（一个技术术语）接口的行为。这里是一个例子：
