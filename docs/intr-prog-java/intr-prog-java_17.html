<html><head></head><body>
        

                            
                    <h1 class="header-title">Lambda Expressions and Functional Programming</h1>
                
            
            
                
<p>This chapter explains the concept of functional programming. It provides an overview of the functional interfaces that come with JDK, explains how to use them in lambda expressions, and how to write lambda expressions in the most concise style.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>Functional programming</li>
<li>Functional interfaces</li>
<li>Lambda expressions</li>
<li>Method references</li>
<li>Exercise – Using method references for creating a new object</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Functional programming</h1>
                
            
            
                
<p>Functional programming allows us to treat a block of code (a function) like an object, passing it as a parameter or as a return value of a method. This feature is present in many programming languages. It does not require us to manage the object state. The function is stateless. Its result depends only on the input data, no matter how many times it was called. This style makes the outcome more predictable, which is the most attractive aspect of functional programming.</p>
<p>Without functional programming, the only way to pass a functionality as a parameter in Java would be through writing a class that implements an interface, creating its object, and then passing it as a parameter. But even the least involved style—using the anonymous class—requires writing too much of the boilerplate code. Using functional interfaces and lambda expressions makes the code shorter, clearer, and more expressive.</p>
<p>Adding it to Java increases parallel programming capabilities by shifting the responsibility for parallelism from the client code to the library. Before that, in order to process elements of Java collections, the client code had to iterate over the collection and organize processing. In Java 8, new (default) methods were added that accept a function (the implementation of a functional interface) as a parameter and then apply it to each element of the collection in parallel or not, depending on the internal processing algorithm. So, it is the library's responsibility to organize parallel processing.</p>
<p>Throughout this chapter, we will define and explain these Java features—functional interfaces and lambda expressions—and demonstrate their applicability in code examples. They make functions the first-class citizens of the language on the same level of importance as objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is a functional interface?</h1>
                
            
            
                
<p>In fact, you have already seen elements of functional programming in our demonstration code. One example is the <kbd>forEach(Consumer consumer)</kbd> method, available for every <kbd>Iterable</kbd>, where <kbd>Consumer</kbd> is a functional interface. Another example is the <kbd>removeIf(Predicate predicate)</kbd> method, available for every <kbd>Collection</kbd> object. The passed-in <kbd>Predicate</kbd> object is a function – an implementation of a functional interface. Similarly, the <kbd>sort(Comparator comparator)</kbd> and <kbd>replaceAll(UnaryOperator uo)</kbd> methods in the <kbd>List</kbd> interface and several <kbd>compute()</kbd> methods in <kbd>Map</kbd> are examples of functional programming.</p>
<p>A functional interface is an interface that has only one abstract method, including those that were inherited from the parent interface.</p>
<p>To help avoid runtime errors, an <kbd>@FunctionalInterface</kbd> annotation was introduced in Java 8 that tells the compiler about the intent, so the compiler can check to see whether there is truly only one abstract method in the annotated interface. Let's review the following interfaces of the same line of inheritance:</p>
<pre>@FunctionalInterface<br/>interface A {<br/>  void method1();<br/>  default void method2(){}<br/>  static void method3(){}<br/>}<br/><br/>@FunctionalInterface<br/>interface B extends A {<br/>  default void method4(){}<br/>}<br/><br/>@FunctionalInterface<br/>interface C extends B {<br/>  void method1();<br/>}<br/><br/>//@FunctionalInterface  //compilation error<br/>interface D extends C {<br/>  void method5();<br/>}</pre>
<p>Interface <kbd>A</kbd> is a functional interface because it has only one abstract method: <kbd>method1()</kbd>. Interface <kbd>B</kbd> is also a functional interface because it has only one abstract method too – the same <kbd>method1()</kbd> inherited from interface <kbd>A</kbd>. Interface <kbd>C</kbd> is a functional interface because it has only one abstract method, <kbd>method1()</kbd>, which overrides the abstract <kbd>method1()</kbd> method of the parent interface <kbd>A</kbd>. Interface <kbd>D</kbd> cannot be a functional interface because it has two abstract methods – <kbd>method1()</kbd>, from the parent interface <kbd>A</kbd>, and <kbd>method5()</kbd>.</p>
<p>When the <kbd>@FunctionalInterface</kbd> annotation is used, it tells the compiler to check on the presence of only one abstract method, and it warns the programmer, who reads the code, that this interface has only one abstract method intentionally. Otherwise, the programmer may waste time enhancing the interface only to discover later that it cannot be done.</p>
<p>For the same reason, the <kbd>Runnable</kbd> and <kbd>Callable</kbd> interfaces that existed in Java since its early versions were annotated in Java 8 as <kbd>@FunctionalInterface</kbd>. It makes this distinction explicit and serves as a reminder to its users and to those who might attempt to add another abstract method:</p>
<pre>@FunctionalInterface<br/>interface Runnable { <br/>  void run(); <br/>} <br/>@FunctionalInterface<br/>interface Callable&lt;V&gt; { <br/>  V call() throws Exception; <br/>}</pre>
<p>As you can see, creating a functional interface is easy. But before doing that, consider using one of the 43 functional interfaces provided in the <kbd>java.util.function</kbd> package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ready-to-use standard functional interfaces</h1>
                
            
            
                
<p>Most of the interfaces provided in the <kbd>java.util.function</kbd> package are specializations of the following four interfaces: <kbd>Function</kbd>, <kbd>Consumer</kbd>, <kbd>Supplier</kbd>, and <kbd>Predicate</kbd>. Let's review them and then have a short overview of the rest of the 39 standard functional interfaces.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Function&lt;T, R&gt;</h1>
                
            
            
                
<p>The notation of this and other functional <kbd>&lt;indexentry content="standard functional interfaces:function"&gt;</kbd> interfaces includes listing of the types of the input data (<kbd>T</kbd>) and the returned data (<kbd>R</kbd>). So, <kbd>Function&lt;T, R&gt;</kbd> means that the only abstract method of this interface accepts an argument of type <kbd>T</kbd> and produces a result of type <kbd>R</kbd>. You can find the name of that abstract method by reading the online documentation. In the case of the <kbd>Function&lt;T, R&gt;</kbd> interface, its method is <kbd>R apply(T)</kbd>.</p>
<p>After learning all that, we can create an implementation of this interface using an anonymous class:</p>
<pre>Function&lt;Integer, Double&gt; multiplyByTen = new Function&lt;Integer, Double&gt;(){<br/>  public Double apply(Integer i){<br/>    return i * 10.0;<br/>  }<br/>};</pre>
<p>It is up to the programmer to decide which actual type will be <kbd>T</kbd> (the input parameter) and which type will be <kbd>R</kbd> (the returned value). In our example, we have decided that the input parameters will be of the <kbd>Integer</kbd> type and the result will be of the <kbd>Double</kbd> type. As you have probably realized by now, the types can be reference types only, and the boxing and unboxing of primitive types is performed automatically.</p>
<p>We can now use our new <kbd>Function&lt;Integer, Double&gt; multiplyByTen</kbd> function any way we need. We can just use it directly, as follows:</p>
<pre>System.out.println(multiplyByTen.apply(1)); //prints: 10.0</pre>
<p>Or we can create a method that accepts this function as a parameter:</p>
<pre>void useFunc(Function&lt;Integer, Double&gt; processingFunc, int input){<br/>  System.out.println(processingFunc.apply(input));<br/>}</pre>
<p>We can then pass our function into this method and let the method use it:</p>
<pre>useFunc(multiplyByTen, 10);     //prints: 100.00<br/></pre>
<p>We can also create a method that will generate a function whenever we need one:</p>
<pre>Function&lt;Integer, Double&gt; createMultiplyBy(double num){<br/>  Function&lt;Integer, Double&gt; func = new Function&lt;Integer, Double&gt;(){<br/>    public Double apply(Integer i){<br/>      return i * num;<br/>    }<br/>  };<br/>  return func;<br/>}</pre>
<p>Using the preceding method, we can write the following code:</p>
<pre>Function&lt;Integer, Double&gt; multiplyByFive = createMultiplyBy(5);<br/>System.out.println(multiplyByFive.apply(1)); //prints: 5.0<br/>useFunc(multiplyByFive, 10);                 //prints: 50.0<br/></pre>
<p>In the next section, we will introduce lambda expressions and will show how they can be used to express the functional interface implementation with much less code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Consumer&lt;T&gt;</h1>
                
            
            
                
<p>By looking at the <kbd>Consumer&lt;T&gt;</kbd> interface definition, you can already guess that this interface has an abstract method that accepts a parameter of the <kbd>T</kbd> type &lt;indexentry content="standard functional interfaces:Consumer"&gt;and does not return anything. From the documentation of the <kbd>Consumer&lt;T&gt;</kbd> interface, we learn that its abstract method is <kbd>void accept(T)</kbd>, which means that, for example, we can implement it as follows:</p>
<pre>Consumer&lt;Double&gt; printResult = new Consumer&lt;Double&gt;() {<br/>  public void accept(Double d) {<br/>    System.out.println("Result=" + d);<br/>  }<br/>};<br/>printResult.accept(10.0);         //prints: Result=10.0<br/></pre>
<p>Or we can create a method that will generate the function:</p>
<pre>Consumer&lt;Double&gt; createPrintingFunc(String prefix, String postfix){<br/>  Consumer&lt;Double&gt; func = new Consumer&lt;Double&gt;() {<br/>    public void accept(Double d) {<br/>      System.out.println(prefix + d + postfix);<br/>    }<br/>  };<br/>  return func;<br/>}</pre>
<p>Now we can use it as follows:</p>
<pre>Consumer&lt;Double&gt; printResult = createPrintingFunc("Result=", " Great!");<br/>printResult.accept(10.0);    //prints: Result=10.0 Great!<br/></pre>
<p>We can also create a new method that not only accepts a processing function as a parameter but also a printing function too:</p>
<pre>void processAndConsume(int input, <br/>                       Function&lt;Integer, Double&gt; processingFunc, <br/>                                          Consumer&lt;Double&gt; consumer){<br/>  consumer.accept(processingFunc.apply(input));<br/>}</pre>
<p>We can then write the following code:</p>
<pre>Function&lt;Integer, Double&gt; multiplyByFive = createMultiplyBy(5);<br/>Consumer&lt;Double&gt; printResult = createPrintingFunc("Result=", " Great!");<br/>processAndConsume(10, multiplyByFive, printResult); //Result=50.0 Great! </pre>
<p>As we have mentioned before, in the next section, we will introduce lambda expressions and will show how they can be used to express the functional interface implementation with much less code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Supplier&lt;T&gt;</h1>
                
            
            
                
<p>Here is a trick question: guess the input and the output types of the abstract method of the <kbd>Supplier&lt;T&gt;</kbd> interface. The answer is: it accepts no parameters and returns the <kbd>T</kbd> type. As you understand now, the difference is in the name of the interface itself. It should give you a hint: the consumer just consumes and returns nothing, while the supplier just supplies without any input. The abstract method of the <kbd>Supplier&lt;T&gt;</kbd> interface is <kbd>T get()</kbd>.</p>
<p>Similar to the previous functions, we can write the supplier generating method:</p>
<pre>Supplier&lt;Integer&gt; createSuppplier(int num){<br/>  Supplier&lt;Integer&gt; func = new Supplier&lt;Integer&gt;() {<br/>    public Integer get() { return num; }<br/>  };<br/>  return func;<br/>}</pre>
<p>We can now write a method that accepts only functions:</p>
<pre>void supplyProcessAndConsume(Supplier&lt;Integer&gt; input, <br/>                             Function&lt;Integer, Double&gt; process, <br/>                                      Consumer&lt;Double&gt; consume){<br/>  consume.accept(processFunc.apply(input.get()));<br/>}</pre>
<p>Notice how the output type of the <kbd>input</kbd> function is the same as the input of the <kbd>process</kbd> function, which returns the same type as consumed by the <kbd>consume</kbd> function. It makes the following code possible:</p>
<pre>Supplier&lt;Integer&gt; supply7 = createSuppplier(7);<br/>Function&lt;Integer, Double&gt; multiplyByFive = createMultiplyBy(5);<br/>Consumer&lt;Double&gt; printResult = createPrintingFunc("Result=", " Great!");<br/>supplyProcessAndConsume(supply7, multiplyByFive, printResult); <br/>                                            //prints: Result=35.0 Great!<br/></pre>
<p>At this point, we hope, you start to appreciate the value functional programming brings to the table. It allows us to pass around chunks of functionality that can be plugged into the middle of an algorithm without needing to create an object. Static methods do not require creating an object either, but they are shared by all application threads because they are unique in the JVM. Meanwhile, each function is an object and can be either unique in the JVM (if assigned to a static variable) or created for each processing thread (which typically is the case). It has very little coding overhead and can have even less plumbing when used in a lambda expression – the topic of our next section.</p>
<p>So far, we have demonstrated how a function can be plugged into the existing control-flow expression. And now we will describe the last missing piece – a function that represents the decision-making construct that can be passed around as an object too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Predicate&lt;T&gt;</h1>
                
            
            
                
<p>This is an interface that represents a Boolean-valued function that has a single method: <kbd>boolean test(T)</kbd>. Here is an example of a method that creates a <kbd>Predicate&lt;Integer&gt;</kbd> function:</p>
<pre>Predicate&lt;Integer&gt; createTestSmallerThan(int num){<br/>  Predicate&lt;Integer&gt; func = new Predicate&lt;Integer&gt;() {<br/>    public boolean test(Integer d) {<br/>      return d &lt; num;<br/>    }<br/>  };<br/>  return func;<br/>}</pre>
<p>We can use it to add some logic to the processing method:</p>
<pre>void supplyDecideProcessAndConsume(Supplier&lt;Integer&gt; input, <br/>                                  Predicate&lt;Integer&gt; test, <br/>                                   Function&lt;Integer, Double&gt; process, <br/>                                            Consumer&lt;Double&gt; consume){<br/>  int in = input.get();<br/>  if(test.test(in)){<br/>    consume.accept(process.apply(in));<br/>  } else {<br/>    System.out.println("Input " + in + <br/>                     " does not pass the test and not processed.");<br/>  }<br/>}</pre>
<p>And the following code demonstrates its usage:</p>
<pre>Supplier&lt;Integer&gt; input = createSuppplier(7);<br/>Predicate&lt;Integer&gt; test = createTestSmallerThan(5);<br/>Function&lt;Integer, Double&gt; multiplyByFive = createMultiplyBy(5);<br/>Consumer&lt;Double&gt; printResult = createPrintingFunc("Result=", " Great!");<br/>supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);<br/>             //prints: Input 7 does not pass the test and not processed.</pre>
<p>Let's set the input to 3, for example:</p>
<pre>Supplier&lt;Integer&gt; input = createSuppplier(3)</pre>
<p>The preceding code would result in the following output:</p>
<pre><strong>Result=15.0 Great!</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Other standard functional interfaces</h1>
                
            
            
                
<p>The other 39 functional interfaces in the <kbd>java.util.function</kbd> package are variations of the four interfaces we have just reviewed. These variations are created in order to achieve one or any combination of the following:</p>
<ul>
<li>Better performance by avoiding autoboxing and unboxing via the explicit usage of the integer, double, or long primitives</li>
<li>Allowing two input parameters</li>
<li>A shorter notation</li>
</ul>
<p>Here are just a few of examples:</p>
<ul>
<li><kbd>IntFunction&lt;R&gt;</kbd> with the <kbd>R apply(int)</kbd> method provides shorter notation (without generics for the input parameter type) and avoids autoboxing by requiring the <kbd>int</kbd> primitive as the parameter</li>
<li><kbd>BiFunction&lt;T,U,R&gt;</kbd> with the <kbd>R apply(T,U)</kbd> method allows two input parameters</li>
<li><kbd>BinaryOperator&lt;T&gt;</kbd> with the <kbd>T apply(T,T)</kbd> method allows two input parameters of the <kbd>T</kbd> type and returns a value of the same <kbd>T</kbd> type</li>
<li><kbd>IntBinaryOperator</kbd> with the <kbd>int applAsInt(int,int)</kbd> method accepts two parameters of the <kbd>int</kbd> type and returns the value of the <kbd>int</kbd> type</li>
</ul>
<p>If you are going to use functional interfaces, we encourage you to study the API of the interfaces of the <kbd>java.util.functional</kbd> package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Chaining standard functions</h1>
                
            
            
                
<p>Most of the functional interfaces in the <kbd>java.util.function</kbd> package have default methods that allow us to build a chain (also called a pipe or pipeline) of functions that pass the result of one as the input parameter to another, thus composing a new complex function. For example:</p>
<pre>Function&lt;Double, Long&gt; f1 = d -&gt; Double.valueOf(d / 2.).longValue();<br/>Function&lt;Long, String&gt; f2 = l -&gt; "Result: " + (l + 1);<br/>Function&lt;Double, String&gt; f3 = f1.andThen(f2);<br/>System.out.println(f3.apply(4.));            //prints: 3<br/></pre>
<p>As you can see from the preceding code, we have created a new <kbd>f3</kbd> function by combining the <kbd>f1</kbd> and <kbd>f2</kbd> functions using the <kbd>andThen()</kbd> method. That's the idea behind the methods we are going to explore in this section. First, we express the functions as anonymous classes and, in the following section, we introduce the lambda expressions that we used in the preceding example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Chain two Function&lt;T,R&gt;</h1>
                
            
            
                
<p>We can use the <kbd>andThen(Function after)</kbd> default method of the <kbd>Function</kbd> interface. We have already created the <kbd>Function&lt;Integer, Double&gt; createMultiplyBy()</kbd> method:</p>
<pre>Function&lt;Integer, Double&gt; createMultiplyBy(double num){<br/>  Function&lt;Integer, Double&gt; func = new Function&lt;Integer, Double&gt;(){<br/>    public Double apply(Integer i){<br/>      return i * num;<br/>    }<br/>  };<br/>  return func; </pre>
<p>We can also write another method that creates a subtracting function with the <kbd>Double</kbd> input type, so we can chain it to the multiplying function:</p>
<pre>private static Function&lt;Double, Long&gt; createSubtractInt(int num){<br/>  Function&lt;Double, Long&gt; func = new Function&lt;Double, Long&gt;(){<br/>    public Long apply(Double dbl){<br/>      return Math.round(dbl - num);<br/>    }<br/>  };<br/>  return func;<br/>}<br/><br/></pre>
<p>Now we can write the following code:</p>
<pre>Function&lt;Integer, Double&gt; multiplyByFive = createMultiplyBy(5);<br/>System.out.println(multiplyByFive.apply(2));  //prints: 10.0<br/><br/>Function&lt;Double, Long&gt; subtract7 = createSubtractInt(7);<br/>System.out.println(subtract7.apply(11.0));   //prints: 4<br/><br/>long r = multiplyByFive.andThen(subtract7).apply(2);<br/>System.out.println(r);                          //prints: 3<br/></pre>
<p>As you can see, the <kbd>multiplyByFive.andThen(subtract7)</kbd> chain acts effectively as <kbd>Function&lt;Integer, Long&gt; multiplyByFiveAndSubtractSeven</kbd>.</p>
<p>The <kbd>Function</kbd> interface has another default method, <kbd>Function&lt;V,R&gt; compose(Function&lt;V,T&gt; before)</kbd>, that also allows us to chain two functions. The function that has to be executed first can be passed as the <kbd>before</kbd> parameter into the <kbd>compose()</kbd> method of the second function:</p>
<pre>boolean r = subtract7.compose(multiplyByFive).apply(2);<br/>System.out.println(r);                          //prints: 3         <br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Chain two Consumer&lt;T&gt;</h1>
                
            
            
                
<p>The <kbd>Consumer</kbd> interface has the <kbd>andThen(Consumer after)</kbd> method too. We have already written the method that creates the printing function:</p>
<pre>Consumer&lt;Double&gt; createPrintingFunc(String prefix, String postfix){<br/>  Consumer&lt;Double&gt; func = new Consumer&lt;Double&gt;() {<br/>    public void accept(Double d) {<br/>      System.out.println(prefix + d + postfix);<br/>    }<br/>  };<br/>  return func;<br/>}</pre>
<p>And now we can create and chain two printing functions, as follows:</p>
<pre>Consumer&lt;Double&gt; print21By = createPrintingFunc("21 by ", "");<br/>Consumer&lt;Double&gt; equalsBy21 = createPrintingFunc("equals ", " by 21");<br/>print21By.andThen(equalsBy21).accept(2d);  <br/>//prints: 21 by 2.0 <br/>//        equals 2.0 by 21<br/></pre>
<p>As you can see in the <kbd>Consumer</kbd> chain, both functions consume the same value in the sequence defined by the chain.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Chain two Predicate&lt;T&gt;</h1>
                
            
            
                
<p>The <kbd>Supplier</kbd> interface does not have default methods, while the <kbd>Predicate</kbd> interface has one static method, <kbd>isEqual(Object targetRef)</kbd>, and three default methods: <kbd>and(Predicate other)</kbd>, <kbd>negate()</kbd>, and <kbd>or(Predicate other)</kbd>. To demonstrate usage of the <kbd>and(Predicate other)</kbd> and <kbd>or(Predicate other)</kbd> methods, for example, let's write the methods that create two <kbd>Predicate&lt;Double&gt;</kbd> functions. One function checks whether the value is smaller than the input:</p>
<pre>Predicate&lt;Double&gt; testSmallerThan(double limit){<br/>  Predicate&lt;Double&gt; func = new Predicate&lt;Double&gt;() {<br/>    public boolean test(Double num) {<br/>      System.out.println("Test if " + num + " is smaller than " + limit);<br/>      return num &lt; limit;<br/>    }<br/>  };<br/>  return func;<br/>}</pre>
<p>Another function checks whether the value is bigger than the input:</p>
<pre>Predicate&lt;Double&gt; testBiggerThan(double limit){<br/>  Predicate&lt;Double&gt; func = new Predicate&lt;Double&gt;() {<br/>    public boolean test(Double num) {<br/>      System.out.println("Test if " + num + " is bigger than " + limit);<br/>      return num &gt; limit;<br/>    }<br/>  };<br/>  return func;<br/>}</pre>
<p>Now we can create two <kbd>Predicate&lt;Double&gt;</kbd> functions and chain them:</p>
<pre>Predicate&lt;Double&gt; isSmallerThan20 = testSmallerThan(20d);<br/>System.out.println(isSmallerThan20.test(10d));<br/>     //prints: Test if 10.0 is smaller than 20.0<br/>     //        true<br/><br/>Predicate&lt;Double&gt; isBiggerThan18 = testBiggerThan(18d);<br/>System.out.println(isBiggerThan18.test(10d));<br/>    //prints: Test if 10.0 is bigger than 18.0<br/>    //        false<br/><br/>boolean b = isSmallerThan20.and(isBiggerThan18).test(10.);<br/>System.out.println(b);<br/>    //prints: Test if 10.0 is smaller than 20.0<br/>    //        Test if 10.0 is bigger than 18.0<br/>    //        false<br/><br/>b = isSmallerThan20.or(isBiggerThan18).test(10.);<br/>System.out.println(b);<br/>    //prints: Test if 10.0 is smaller than 20.0<br/>    //        true<br/></pre>
<p>As you can see, the <kbd>and()</kbd> method required execution of each of the functions, while the <kbd>or()</kbd> method did not execute the second function as soon as the first one in the chain returned <kbd>true</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">identity() and other default methods</h1>
                
            
            
                
<p>Functional interfaces of the <kbd>java.util.function</kbd> package have other helpful default methods. The one that stands out is the <kbd>identity()</kbd> method, which returns a function that always returns its input argument:</p>
<pre>Function&lt;Integer, Integer&gt; id = Function.identity();<br/>System.out.println(id.apply(4));          //prints: 4<br/></pre>
<p>The <kbd>identity()</kbd> method is very helpful when some procedure requires providing a certain function, but you do not want the provided function to change anything. In such cases, you create an identity function with the necessary output type. For example, in one of our previous code snippets, we may decide that the <kbd>multiplyByFive</kbd> function should not change anything in the <kbd>multiplyByFive.andThen(subtract7)</kbd> chain:</p>
<pre>Function&lt;Double, Double&gt; multiplyByFive = Function.identity();<br/>System.out.println(multiplyByFive.apply(2.));  //prints: 2.0<br/><br/>Function&lt;Double, Long&gt; subtract7 = createSubtractInt(7);<br/>System.out.println(subtract7.apply(11.0));    //prints: 4<br/><br/>long r = multiplyByFive.andThen(subtract7).apply(2.);<br/>System.out.println(r);                       //prints: -5<br/></pre>
<p>As you can see, the  <kbd>multiplyByFive</kbd> function did not do anything with the input parameter <kbd>2</kbd>, so the result (after <kbd>7</kbd> was subtracted) is <kbd>-5</kbd>.</p>
<p>Other default methods are mostly related to conversion and boxing and unboxing, but also extracting minimum and maximum values of two parameters. If you are interested, you can look through the API of interfaces of the <kbd>java.util.function</kbd> package and get a feeling for the possibilities.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lambda expressions</h1>
                
            
            
                
<p>The examples in the previous section (that used anonymous classes for the implementation of functional interfaces) looked bulky and felt excessively verbose. For one, there was no need to repeat the interface name, because we had declared it already as the type for the object reference. And, second, in the case of a functional interface that had only one abstract method, there is no need to specify the method name that has to be implemented. The compiler and Java runtime can figure it out. All we need is to provide the new functionality. Lambda expressions were introduced for exactly this purpose.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is a lambda expression?</h1>
                
            
            
                
<p>The term lambda comes from lambda calculus—a universal model of computation that can be used to simulate any Turing machine. It was introduced by mathematician, Alonzo Church, in the 1930s. A lambda expression is a function, implemented in Java as an anonymous method, that also allows us to omit modifiers, return types, and parameter types. That makes for a very compact notation.</p>
<p>The syntax of a lambda expression includes the list of parameters, an arrow token <kbd>-&gt;</kbd>, and a body. The list of parameters can be empty <kbd>()</kbd>, without brackets (if there is only one parameter), or a comma-separated list of parameters surrounded by brackets. The body can be a single expression or a statement block. </p>
<p>Let us look at a few examples:</p>
<ul>
<li><kbd>() -&gt; 42;</kbd> always returns <kbd>42</kbd></li>
<li><kbd>x -&gt; x + 1;</kbd> increments the <kbd>x</kbd> variable by <kbd>1</kbd></li>
<li><kbd>(x, y) -&gt; x * y;</kbd> multiplies <kbd>x</kbd> by <kbd>y</kbd> and returns the result</li>
<li><kbd>(char x) -&gt; x == '$';</kbd> compares the value of the <kbd>x</kbd> variable and the <kbd>$</kbd> symbol, and returns a Boolean value</li>
<li><kbd>x -&gt; {  System.out.println("x=" + x); };</kbd> prints the <kbd>x</kbd> value with the <kbd>x=</kbd> prefix</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Re-implementing functions</h1>
                
            
            
                
<p>We can rewrite our functions, created in the previous section, using lambda expressions, as follows:</p>
<pre>Function&lt;Integer, Double&gt; createMultiplyBy(double num){<br/>  Function&lt;Integer, Double&gt; func = i -&gt; i * num;<br/>  return func;<br/>}<br/>Consumer&lt;Double&gt; createPrintingFunc(String prefix, String postfix){<br/>  Consumer&lt;Double&gt; func = d -&gt; System.out.println(prefix + d + postfix);<br/>  return func;<br/>}<br/>Supplier&lt;Integer&gt; createSuppplier(int num){<br/>  Supplier&lt;Integer&gt; func = () -&gt; num;<br/>  return func;<br/>}<br/>Predicate&lt;Integer&gt; createTestSmallerThan(int num){<br/>  Predicate&lt;Integer&gt; func = d -&gt; d &lt; num;<br/>  return func;<br/>}</pre>
<p>We don't repeat the name of the implemented interface because it is specified as the return type in the method signature. And we do not specify the name of the abstract method either because it is the only method of the interface that has to be implemented. Writing such a compact and efficient code became possible because of the combination of the lambda expression and functional interface.</p>
<p>Looking at the preceding examples, you probably realize that there is no need to have methods that create a function anymore. Let's change the code that calls the <kbd>supplyDecideProcessAndConsume()</kbd> method:</p>
<pre>void supplyDecideProcessAndConsume(Supplier&lt;Integer&gt; input, <br/>                                   Predicate&lt;Integer&gt; test, <br/>                                   Function&lt;Integer, Double&gt; process, <br/>                                            Consumer&lt;Double&gt; consume){<br/>  int in = input.get();<br/>  if(test.test(in)){<br/>    consume.accept(process.apply(in));<br/>  } else {<br/>    System.out.println("Input " + in + <br/>                 " does not pass the test and not processed.");<br/>  }<br/>}</pre>
<p>Let's revisit the following lines: </p>
<pre>Supplier&lt;Integer&gt; input = createSuppplier(7);<br/>Predicate&lt;Integer&gt; test = createTestSmallerThan(5);<br/>Function&lt;Integer, Double&gt; multiplyByFive = createMultiplyBy(5);<br/>Consumer&lt;Double&gt; printResult = createPrintingFunc("Result=", " Great!");<br/>supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);</pre>
<p>We can change the preceding code to the following without changing the functionality:</p>
<pre>Supplier&lt;Integer&gt; input = () -&gt; 7;<br/>Predicate&lt;Integer&gt; test = d -&gt; d &lt; 5.;<br/>Function&lt;Integer, Double&gt; multiplyByFive = i -&gt; i * 5.;;<br/>Consumer&lt;Double&gt; printResult = <br/>                     d -&gt; System.out.println("Result=" + d + " Great!");<br/>supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult); <br/></pre>
<p>We can even inline the preceding functions and write the preceding code in one line like this:</p>
<pre>supplyDecideProcessAndConsume(() -&gt; 7, d -&gt; d &lt; 5, i -&gt; i * 5., <br/>                    d -&gt; System.out.println("Result=" + d + " Great!")); <br/></pre>
<p>Notice how much more transparent the definition of the printing function has become. That is the power and the beauty of lambda expressions in combination with functional interfaces. In <a href="be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml">Chapter 18</a>, <em>Streams and Pipelines</em>, you will see that lambda expressions are, in fact, the only way to process streamed data. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lambda limitations</h1>
                
            
            
                
<p>There are two aspects of a lambda expression that we would like to point out and clarify, which are:</p>
<ul>
<li>If a lambda expression uses a local variable created outside it, this local variable has to be final or effectively final (not re-assigned in the same context)</li>
<li>The <kbd>this</kbd> keyword in a lambda expression refers to the enclosing context, and not the lambda expression itself</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Effectively final local variable</h1>
                
            
            
                
<p>As in the anonymous class, the variable, created outside and used inside the lambda expression, becomes effectively final and cannot be modified. You can write the following:</p>
<pre>int x = 7;<br/>//x = 3;       //compilation error<br/>int y = 5;<br/>double z = 5.;<br/>supplyDecideProcessAndConsume(() -&gt; x, d -&gt; d &lt; y, i -&gt; i * z,<br/>            d -&gt; { //x = 3;      //compilation error<br/>                   System.out.println("Result=" + d + " Great!"); } );<br/></pre>
<p>But, as you can see, we cannot change the value of the local variable used in the lambda expression. The reason for this restriction is that a function can be passed around and executed in different contexts (different threads, for example), and the attempt to synchronize these contexts would defeat the original idea of the stateless function and independent distributed evaluation of the expression. That is why all the local variables used in the lambda expression are effectively final, meaning that they can either be declared final explicitly or become final by virtue of their usage in a lambda expression. </p>
<p>There is one possible workaround for this limitation. If the local variable is of a reference type (but not <kbd>String</kbd> or a primitive wrapping type), it is possible to change its state even if this local variable is used in the lambda expression:</p>
<pre>class A {<br/>  private int x;<br/>  public int getX(){ return this.x; }<br/>  public void setX(int x){ this.x = x; }<br/>}<br/>void localVariable2(){<br/>  A a = new A();<br/>  a.setX(7);<br/>  a.setX(3);<br/>  int y = 5;<br/>  double z = 5.;<br/>  supplyDecideProcessAndConsume(() -&gt; a.getX(), d -&gt; d &lt; y, i -&gt; i * z,<br/>               d -&gt; { a.setX(5);<br/>    System.out.println("Result=" + d + " Great!"); } );<br/>}</pre>
<p>But this workaround should be used only when really needed and has to be done with care because of the danger of unexpected side effects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The this keyword interpretation</h1>
                
            
            
                
<p>One principal difference between the anonymous class and lambda expressions is the interpretation of the <kbd>this</kbd> keyword. Inside an anonymous class, it refers to the instance of the anonymous class. Inside a lambda expression, <kbd>this</kbd> refers to the instance of the class that surrounds the expression, also called an <em>enclosing instance</em>, <em>enclosing context</em>, or <em>enclosing scope</em>.</p>
<p>Let's write a <kbd>ThisDemo</kbd> class that illustrates the difference:</p>
<pre>class ThisDemo {<br/>  private String field = "ThisDemo.field";<br/>  public void useAnonymousClass() {<br/>    Consumer&lt;String&gt; consumer = new Consumer&lt;&gt;() {<br/>      private String field = "AnonymousClassConsumer.field";<br/>      public void accept(String s) {<br/>        System.out.println(this.field);<br/>      }<br/>    };<br/>    consumer.accept(this.field);<br/>  }<br/>  public void useLambdaExpression() {<br/>    Consumer&lt;String&gt; consumer = consumer = s -&gt; {<br/>      System.out.println(this.field);<br/>    };<br/>    consumer.accept(this.field);<br/>  }<br/><br/>}</pre>
<p>As you can see, <kbd>this</kbd> inside the anonymous class refers to the anonymous class instance, while <kbd>this</kbd> in the lambda expression refers to the enclosing class instance. Lambda expressions just do not have and cannot have a field. If we execute the preceding methods, the output confirms our assumptions:</p>
<pre>ThisDemo d = new ThisDemo();<br/>d.useAnonymousClass();   //prints: AnonymousClassConsumer.field<br/>d.useLambdaExpression(); //prints: ThisDemo.field<br/></pre>
<p>The lambda expression is not a class instance and cannot be referred to by <kbd>this</kbd>. According to Java Specification, such an approach <em>allows more flexibility for implementations</em> by <em>treating [this] the same as in the surrounding context.</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Method references</h1>
                
            
            
                
<p>Let's look at our last implementation of the call to the <kbd>supplyDecidePprocessAndConsume()</kbd> method:</p>
<pre>supplyDecideProcessAndConsume(() -&gt; 7, d -&gt; d &lt; 5, i -&gt; i * 5., <br/>                    d -&gt; System.out.println("Result=" + d + " Great!")); </pre>
<p>The functions we have used are pretty trivial. In real-life code, each of them may require a multiple-line implementation. In such a case, to put a code block inline would make the code almost unreadable. In such cases, referring to the methods with the necessary implementation helps. Let's assume we have the following <kbd>Helper</kbd> class:</p>
<pre>public class Helper {<br/>  public double calculateResult(int i){<br/>    // Maybe many lines of code here<br/>    return i* 5;<br/>  }<br/>  public static void printResult(double d){<br/>    // Maybe many lines of code here<br/>    System.out.println("Result=" + d + " Great!");<br/>  }<br/>}</pre>
<p>The lambda expressions in the <kbd>Lambdas</kbd> class may refer to the methods of the <kbd>Helper</kbd> and <kbd>Lambdas</kbd> classes, as follows:</p>
<pre>public class Lambdas {<br/>  public void methodReference() {<br/>    Supplier&lt;Integer&gt; input = () -&gt; generateInput();<br/>    Predicate&lt;Integer&gt; test = d -&gt; checkValue(d);<br/>    Function&lt;Integer, Double&gt; multiplyByFive = <br/>                                  i -&gt; new Helper().calculateResult(i);<br/>    Consumer&lt;Double&gt; printResult = d -&gt; Helper.printResult(d);<br/>    supplyDecideProcessAndConsume(input, test, <br/>                                           multiplyByFive, printResult);<br/>  }<br/>  private int generateInput(){<br/>    // Maybe many lines of code here<br/>    return 7;<br/>  }<br/>  private static boolean checkValue(double d){<br/>    // Maybe many lines of code here<br/>    return d &lt; 5;<br/>  }<br/>}</pre>
<p>The preceding code reads better already, and the functions may be inlined again:</p>
<pre>supplyDecideProcessAndConsume(() -&gt; generateInput(), d -&gt; checkValue(d), <br/>            i -&gt; new Helper().calculateResult(i), Helper.printResult(d));</pre>
<p>But in such cases, the notation can be made even more compact. When a one-line lambda expression consists of a reference to an existing method, it is possible to further simplify the notation by using a method reference without listing the parameters. </p>
<p>The syntax of the method reference is <kbd>Location::methodName</kbd>, where <kbd>Location</kbd> indicates where (in which object or class) the <kbd>methodName</kbd> method can be found, and the two colons (<kbd>::</kbd>) serve as a separator between the location and the method name. If there are several methods with the same name at the specified location (because of the method overload), the reference method is identified by the signature of the abstract method of the functional interface implemented by the lambda expression.</p>
<p>Using the method reference, the preceding code under <kbd>methodReference()</kbd> method in the <kbd>Lambdas</kbd> class can be rewritten as follows:</p>
<pre>Supplier&lt;Integer&gt; input = this::generateInput;<br/>Predicate&lt;Integer&gt; test = Lambdas::checkValue;<br/>Function&lt;Integer, Double&gt; multiplyByFive = new Helper()::calculateResult;;<br/>Consumer&lt;Double&gt; printResult = Helper::printResult;<br/>supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);<br/></pre>
<p>To inline such functions makes even more sense:</p>
<pre>supplyDecideProcessAndConsume(this::generateInput, Lambdas::checkValue, <br/>                    new Helper()::calculateResult, Helper::printResult);<br/></pre>
<p>You have probably noticed that we have intentionally used different locations and two instance methods and two static methods in order to demonstrate the variety of possibilities.</p>
<p>If it feels like too much to remember, the good news is that a modern IDE (IntelliJ IDEA is one example) can do it for you and convert the code you are writing into the most compact form.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercise – Using the method reference to create a new object</h1>
                
            
            
                
<p>Use the method reference to express creating a new object. Let's assume that we have <kbd>class A{}</kbd>. Replace the following <kbd>Supplier</kbd> function declaration with another one that uses the method reference:</p>
<pre>Supplier&lt;A&gt; supplier = () -&gt; new A();<br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Answer</h1>
                
            
            
                
<p>The answer is:</p>
<pre>Supplier&lt;A&gt; supplier = A::new;<br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter introduced the concept of functional programming. It provided an overview of the functional interfaces that come with JDK and demonstrated how to use them. It also discussed and demonstrated lambda expressions and how effectively they can improve code readability.</p>
<p>The next chapter will make the reader familiar with the powerful concept of datastreams processing. It explains what streams are, how to create them and process their elements, and how to build processing pipelines. It also shows how easily you can organize stream processing in parallel.</p>


            

            
        
    </body></html>