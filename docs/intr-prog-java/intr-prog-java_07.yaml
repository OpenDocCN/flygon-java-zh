- en: Packages and Accessibility (Visibility)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包和可访问性（可见性）
- en: By now, you are already quite familiar with packages. In this chapter, we will
    complete its description and then discuss different levels of accessibility (also
    called visibility) of classes and class members – methods and fields. It all will
    come down to the key concept of object-oriented programming – the encapsulation –
    and lay the foundation for our discussion of object-oriented design principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经非常熟悉包了。在本章中，我们将完成其描述，然后讨论类和类成员（方法和字段）的不同访问级别（也称为可见性）。这将涉及到面向对象编程的关键概念——封装，并为我们讨论面向对象设计原则奠定基础。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is importing?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是导入?
- en: Static importing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态导入
- en: Interface access modifiers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口访问修饰符
- en: Class access modifiers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类访问修饰符
- en: Method access modifiers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法访问修饰符
- en: Property access modifiers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性访问修饰符
- en: Encapsulation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Exercise – Shadowing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-阴影跟读
- en: What is importing?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是导入?
- en: 'Importing allows us to specify a fully qualified class or interface name only
    once at the beginning of the `.java` file, before the class or interface declaration.
    The format of an import statement is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 导入允许我们在`.java`文件的开始（类或接口声明之前）只指定一次完全限定的类或接口名称。导入语句的格式如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example, look at the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看下面的：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From now on, this class can be referred to in the code by its name, `MyApplication`,
    only. It is also possible to import all the classes or interfaces of a package
    using the wildcard character (`*`):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '从现在开始，这个类只能通过它的名称`MyApplication`在代码中引用。也可以使用通配符（`*`）导入包的所有类或接口:'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the preceding import statement imports classes and interfaces of
    the subpackages of the `com.packt.javapath.ch04demo` package. If needed, each
    subpackage has to be imported separately.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的导入语句导入了`com.packt.javapath.ch04demo`包的子包的类和接口。如果需要，必须逐个导入每个子包。
- en: But, before we continue, let's talk about the `.java` file structure and packages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但在继续之前，让我们谈谈`.java`文件结构和包。
- en: Structure of the .java file and packages
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`.java`文件和包的结构'
- en: As you already know, the package name reflects the directory structure, starting
    with the project directory that contains the `.java` files. The name of each `.java`
    file has to be the same as the name of the public class defined in it. The first
    line of the `.java` file is the package statement that starts with the `package` keyword,
    followed by the actual package name—the directory path to this file, in which
    slashes are replaced with dots. Let's look at some examples. We will look primarily
    at the `.java` file that contains a class definition, but we will also look at
    files with interfaces and the `enum` class definition because there is a particular
    type of importing (called static importing) that is primarily used with interfaces
    and `enum`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知道的，包名反映了目录结构，从包含`.java`文件的项目目录开始。每个`.java`文件的名称必须与其中定义的公共类的名称相同。`.java`文件的第一行是以`package`关键字开头的包声明，其后是实际的包名称——本文件的目录路径，其中斜线替换为句点。让我们看一些例子。我们主要关注包含类定义的`.java`文件，但我们也会看一些带有接口和`enum`类定义的文件，因为特殊的导入类型（称为静态导入）主要用于接口和`enum`。
- en: 'We assume that the `src/main/java` (for Linux) or `src\main\java` (for Windows) project
    directory contains all the `.java` files, and the definition of the `MyClass` and
    `MyEnum` classes and the `MyInterface` interface from the package `com.packt.javapath` are
    stored in the files:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设`src/main/java`（对于Linux）或`src\main\java`（对于Windows）项目目录包含所有`.java`文件，并且定义在`com.packt.javapath`包的`MyClass`和`MyEnum`类和`MyInterface`接口的定义存储在文件中：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: or (for Windows)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或（对于Windows）
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first line of each of these files is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件的第一行如下所示：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we do not import anything, then the next line in each file is a class or
    interface declaration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们什么都不导入，则每个文件的下一行是一个类或接口声明。
- en: 'The declaration of the `MyClass` class looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyClass`类的声明如下：'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It consists of the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括以下内容：
- en: An access modifier; one of the classes in the file has to be `public`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符；该文件中的其中一个类必须是`public`
- en: The `class` keyword
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`关键字'
- en: The class name (identifier) that starts with a capital letter by convention
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名（按约定以大写字母开头的标识符）
- en: If the class is a child of another class, the `extends` keyword and the name
    of the parent class
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类是另一个类的子类，则有`extends`关键字和父类的名称
- en: If the class implements one or more interfaces, the `implements` keyword followed
    by the comma-separated list of interfaces it implements
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类实现了一个或多个接口，则有`implements`关键字，后跟它实现的接口的逗号分隔列表
- en: The body of the class (where the fields and methods are defined) surrounded
    by braces, `{}`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的主体（其中定义了字段和方法）用大括号`{}`括起来
- en: 'The declaration of the `MyEnum` class looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyEnum`类的声明如下所示：'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It consists of the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括以下内容：
- en: An access modifier; it has to be `public` if it is the only class defined in
    the file
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符；如果它是文件中定义的唯一类，则必须是`public`
- en: The `enum` keyword
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum`关键字'
- en: The class name (identifier) that starts with a capital letter by convention
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名（标识符），按约定以大写字母开头
- en: No `extends` keyword because the enum type extends the `java.lang.Enum` class implicitly
    and, in Java, a class can have only one parent
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`extends`关键字，因为枚举类型隐式地扩展了`java.lang.Enum`类，在Java中，一个类只能有一个父类
- en: If the class implements one or more interfaces, the `implements` keyword followed
    by the comma-separated list of interfaces it implements
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类实现了一个或多个接口，则有`implements`关键字，后跟它实现的接口的逗号分隔列表
- en: The body of the class (where the constants and methods are defined) surrounded
    by braces, `{}`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的主体（其中定义了常量和方法）用大括号`{}`括起来
- en: 'The declaration of the `MyInterface` interface looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyInterface`接口的声明如下所示：'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It consists of the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括以下内容：
- en: An access modifier; one of the interfaces in the file has to be `public`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符；文件中的一个接口必须是`public`
- en: The `interface` keyword
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface`关键字'
- en: The interface name (identifier) that starts with a capital letter by convention
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口名称（标识符），按约定以大写字母开头
- en: If the interface is a child of one or more interfaces, the `extends` keyword followed
    by the comma-separated list of the parent interfaces
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果接口是一个或多个接口的子接口，则接口后跟`extends`关键字，后跟父接口的逗号分隔列表
- en: The body of the interface (where the fields and methods are defined) surrounded
    by braces, `{}`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的主体（其中定义了字段和方法）用大括号`{}`括起来
- en: 'Without importing, we would need to refer to each class or interface we are
    using by its fully qualified name, which includes the package name and class,
    or interface name. For example, the `MyClass` class declaration would look like
    this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有导入，我们需要通过其完全限定名来引用我们正在使用的每个类或接口，其中包括包名和类或接口名。例如，`MyClass`类的声明将如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or, let''s say we would like to instantiate the `SomeClass` class from the `com.packt.javapath.something` package.
    The fully qualified name of that class would be `com.packt.javapath.something.SomeClass` and
    its object creation statement would look as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，假设我们想要实例化`com.packt.javapath.something`包中的`SomeClass`类。该类的完全限定名称将是`com.packt.javapath.something.SomeClass`，其对象创建语句将如下所示：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is too verbose, isn't it? This is where package importing comes to the rescue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这太冗长了，不是吗？这就是包导入发挥作用的地方。
- en: Single class import
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个类导入
- en: 'To avoid using the fully qualified class or interface name in the code, we
    can add an import statement in the space between the package declaration and class
    or interface declaration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在代码中使用完全限定的类或接口名称，我们可以在包声明和类或接口声明之间的空间中添加一个导入语句：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the import statement allows avoiding usage of the fully qualified
    class name, which makes the code easier to read.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，导入语句允许避免使用完全限定的类名，这使得代码更易于阅读。
- en: Multiple classes import
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个类导入
- en: If several classes or interfaces from the same package are imported, it is possible
    to import all the package members using the asterisk (`*`) wildcard character.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从同一包中导入了多个类或接口，则可以使用星号（`*`）通配符字符导入所有包成员。
- en: 'If `SomeClass` and `SomeOtherClass` belong to the same package, then the import
    statement may look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`SomeClass`和`SomeOtherClass`属于同一个包，则导入语句可能如下所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The advantage of using the asterisk is a shorter list of import statements,
    but such a style hides the names of the imported classes and interfaces. So, the
    programmer may not know exactly where they come from. Besides, when two or more
    packages contain members with the same name, you just have to import them explicitly
    as a single class import. Otherwise, the compiler will generate an error.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用星号的优点是导入语句的列表较短，但这样的风格隐藏了导入的类和接口的名称。因此，程序员可能不知道它们确切来自哪里。此外，当两个或更多的包包含具有相同名称的成员时，你只需将它们明确地导入为单个类导入。否则，编译器会生成一个错误。
- en: On the other hand, the programmers who prefer wildcard importing, argue that
    it helps to prevent accidentally creating a class with a name that exists already
    in one of the imported packages. So, you have to make your own choice when it
    comes to style and configuring your IDE to use or not use the wildcard importing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，偏爱通配符导入的程序员认为它有助于防止意外地创建一个已经存在于其中一个导入包中的类的名称。因此，在风格和配置 IDE 以使用或不使用通配符导入时，你必须自己做出选择。
- en: 'In IntelliJ IDEA, the default style of import is using a wildcard. If you would
    like to switch to a single class import, click on File | Other Settings | Default
    Settings, as in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IntelliJ IDEA 中，默认的导入风格是使用通配符。如果你想切换到单个类导入，请点击 文件 | 其他设置 | 默认设置，如下面的截图所示：
- en: '![](img/15e4c441-99b0-4266-b669-26820d240037.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15e4c441-99b0-4266-b669-26820d240037.png)'
- en: 'On the screen that opens, select Editor | Java and check the Use single class
    import checkbox:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的界面上，选择编辑器 | Java 并勾选使用单个类导入复选框：
- en: '![](img/7dbd6160-11da-4075-afe8-394c3b78582c.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dbd6160-11da-4075-afe8-394c3b78582c.png)'
- en: There are other settings on this page that you might find useful, so try to
    remember how to access it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上还有其他你可能会觉得有用的设置，所以尽量记住如何访问它。
- en: Static import
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态导入
- en: 'Static import allows importing not just a class or an interface but its public
    members—fields and methods—individually. If you look in one of our test classes,
    you will see the following static import statement:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 静态导入允许单独导入一个类或接口的公共成员——字段和方法。如果你查看我们的一个测试类，你会看到以下的静态导入语句：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This statement allowed us to write the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句允许我们写成以下形式：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That is instead of writing this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是不再写这样的代码：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That is one widespread case of static import usage. Another popular case is
    static importing of constants of an interface or `enum`. For example, if we have
    an interface as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是静态导入用法的一个广泛案例。另一个常见的用例是静态导入接口或 `enum` 的常量。例如，如果我们有一个如下所示的接口：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, to use its constants, one can import them statically:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要使用它的常量，可以静态导入它们：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By the way, the same effect could be achieved by importing that `Constants` interface
    non-statically and having the class implement it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，同样的效果也可以通过非静态导入那个 `Constants` 接口并让类实现它来实现：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This style of implementing an interface in order to use their constants is quite
    popular among Java programmers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现接口以使用它们的常量的风格在 Java 程序员中非常流行。
- en: 'An example of using static import in order to use the `enum` constants looks
    similar:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `enum` 常量，使用静态导入的示例看起来类似：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It allows the code to use `DayOfWeek` constants as `MONDAY`, instead of `DayOfWeek.MONDAY`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许代码使用 `DayOfWeek` 常量作为 `MONDAY`，而不是 `DayOfWeek.MONDAY`。
- en: Access modifiers
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: There are three explicit access modifiers—public, private, and protected—and
    one implicit (default) access modifier that is implied when no access modifier
    is set. They can be applied to the top-level class or interface, their members,
    and constructors. A *top-level* class or interface can include a *member* class
    or interface. Other *members* of a class or interface are fields and methods.
    Classes also have *constructors*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个明确的访问修饰符——public、private 和 protected——以及一个隐式的（默认的）访问修饰符，当没有设置访问修饰符时会被暗示。它们可以应用于顶级类或接口、它们的成员和构造函数。顶级类或接口可以包括成员类或接口。类的其他成员包括字段和方法。类还有构造函数。
- en: 'To demonstrate the accessibility, let''s create a `com.packt.javapath.Ch07demo.pack01` package that
    contains two classes and two interfaces:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示可访问性，让我们创建一个包名为 `com.packt.javapath.Ch07demo.pack01` 的包，其中包含两个类和两个接口：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will also create another `com.packt.javapath.Ch07demo.pack02` package with
    one class in it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建另一个包名为 `com.packt.javapath.Ch07demo.pack02` 的包，并在其中放置一个类：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Each of the preceding classes and interfaces is in its own file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的每个类和接口都在自己的文件中：
- en: '![](img/eac9098f-e718-4bd2-ab43-b02aac7aa66e.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eac9098f-e718-4bd2-ab43-b02aac7aa66e.png)'
- en: Now we are ready to explore the accessibility of classes, interfaces, their
    members, and constructors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备探讨类、接口、它们的成员和构造函数的可访问性。
- en: The accessibility of a top-level class or interface
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶级类或接口的可访问性
- en: 'The public class or interface is accessible from anywhere. We can import them
    and access them from another package:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类或接口可从任何地方访问。我们可以导入它们并从另一个包中访问它们：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, the two import statements are commented out because they
    generate an error. That is because in the `DefaultAccessClass01` class and the `DefaultAccessClass01` interface,
    we did not use the access modifier, which made them accessible only to the members
    of the same package.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，两个导入语句被注释掉了，因为它们会生成错误。这是因为在`DefaultAccessClass01`类和`DefaultAccessClass01`接口中，我们没有使用访问修饰符，这使它们只能被同一包中的成员访问。
- en: Without an access modifier, a top-level class or interface can be accessed only
    by the members of the same package.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 没有访问修饰符，顶级类或接口只能被同一包中的成员访问。
- en: Making an access modifier `private` in the declaration of a top-level class
    or interface make them inaccessible, so using a `private` access modifier for
    a top-level class or interface does not make sense.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将顶级类或接口的访问修饰符声明为`private`将使它们无法访问，因此对于顶级类或接口使用`private`访问修饰符是没有意义的。
- en: The `protected` keyword cannot be applied to a top level. This limitation is
    not as obvious. We will see in the next section that `protected` means it is accessible
    to the package members and the children. So, one could argue that `protected`
    access can be applicable to a top-level class or interface too. Yet, the Java
    authors decided not to do it, and the compiler will generate an exception if you
    try to make a top-level class or interface `protected`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`关键字不能应用于顶级。这个限制并不明显。我们将在下一节中看到，`protected`意味着它对包成员和子类可访问。因此，有人可能会认为`protected`访问也适用于顶级类或接口。然而，Java的作者决定不这样做，如果您尝试将顶级类或接口设为`protected`，编译器将生成异常。'
- en: However, `private` and `protected` access modifiers can be applied to inner
    classes or interfaces—the members of the top-level class or interface.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`private`和`protected`访问修饰符可以应用于内部类或接口——顶级类或接口的成员。
- en: Access to class or interface members
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类或接口成员的访问
- en: Even when class or interface members are declared public, they cannot be accessed
    if the enclosing class or interface is inaccessible. So, all of the following
    discussion will be done under the assumption that the class or interface is accessible.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 即使类或接口成员被声明为公共的，如果封闭类或接口是不可访问的，则无法访问它们。因此，以下所有讨论都将在假设类或接口是可访问的情况下进行。
- en: Members of a class or interface can access other members of the same class or
    interface no matter what access modifiers they have. Which makes sense, doesn't
    it? It all happens inside the same enclosing class or interface.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 类或接口的成员可以访问同一类或接口的其他成员，无论它们有什么访问修饰符。这是有道理的，不是吗？这一切都发生在同一个封闭类或接口中。
- en: By default, the interface members are public. So, if an interface itself can
    be accessed, its members without access modifier can be accessed too. And, just
    to remind you, the interface fields are static and final (constants) by default.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，接口成员是公共的。因此，如果可以访问接口本身，则可以访问没有访问修饰符的成员。而且，只是提醒您，接口字段默认为静态和最终（常量）。
- en: The class members, on the other hand, without an access modifier, are accessible
    only to the package members. So, the class or interface may be public, but their
    members are less accessible, if not made public explicitly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，没有访问修饰符的类成员只能被包成员访问。因此，类或接口可能是公共的，但它们的成员是不太可访问的，除非明确地公开。
- en: Private class or interface members are accessible only to the other members
    of the same class or interface. That is the most restricted access possible. Even
    children of the class cannot access their parents' private members.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 私有类或接口成员只能被同一类或接口的其他成员访问。这是最受限制的访问。即使类的子类也不能访问其父类的私有成员。
- en: 'Protected package members are accessible to other members of the same package
    and to the children of the class or interface, which means that protected members
    can be overridden. And that is often used by programmers as an expression of the
    intent: they make those members protected that they expect to be overridden. Otherwise,
    they make them either private or public. Default—no access modifiers—access is
    rarely used.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 包内受保护成员可被同一包中的其他成员以及类或接口的子类访问，这意味着受保护成员可以被重写。这通常被程序员用作意图的表达：他们将那些期望被重写的成员设置为受保护的。否则，他们将它们设置为私有或公共。默认的——无访问修饰符——访问极少被使用。
- en: '**Private**: Allows access from the same class (or interface) only'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有**：只允许同一类（或接口）访问'
- en: '**No modifier (default)**: Allows access from the same class (or interface)
    and the same package'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**无修饰符（默认）**：允许从同一类（或接口）和同一包中访问'
- en: '**Protected**: Allows access from the same class (or interface), the same package,
    and any child'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**受保护**：允许从同一类（或接口）、同一包和任何子类中访问'
- en: '**Public**: Allows access from anywhere'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共**：允许从任何地方访问'
- en: 'The same accessibility rules apply to inner classes and interfaces too. Here
    is an example of a class that contains inner classes and interfaces:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类和接口也遵循相同的访问规则。下面是一个包含内部类和接口的类的示例：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And here is an interface with an inner class and interface:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个带有内部类和接口的接口：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, only default (public) access is allowed for the inner classes
    and interfaces of an interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，接口的内部类和接口只允许默认（公共）访问。
- en: 'And, just to repeat what we have already discussed, we will briefly mention
    some other related aspects of members accessibility:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，为了重申我们已经讨论过的内容，我们将简要提及成员可访问性的一些其他相关方面：
- en: A static nested class (it is an inner class, but is called nested in the case
    of the static class by convention) cannot access non-static members of the same
    class, while they can access it
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态嵌套类（在静态类的情况下被称为嵌套类）无法访问同一类的非静态成员，而它们可以访问它
- en: Being a member of some top-level class, a static nested class can be public, protected,
    package-accessible (default), or private
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为某个顶层类的成员，静态嵌套类可以是公共的、受保护的、包可访问的（默认）、或私有的
- en: Public, protected, and package-accessible members of a class are inherited by
    the child
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的公共、受保护和包可访问成员会被子类继承
- en: The constructor's accessibility is the same as any class member
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数的可访问性与任何类成员相同
- en: As the title of this section has stated, that is all we can say about the accessibility
    of a constructor. Naturally, when we talk about constructors, we talk only about
    classes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节标题所述，这就是我们可以说的关于构造函数的可访问性的一切。当然，当我们谈论构造函数时，我们只谈论类。
- en: 'The interesting thing about constructors is their ability to have private access
    only. It means that a class can provide its own factory method (see [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*), control how each object is constructed,
    and even control how many of them can be put into the circulation. The last feature
    is especially valuable in the case where each object requires access to a certain
    resource (a file or another database) that has limited support for concurrent
    access. Here is how the simplest version of such a factory method with a limited number
    of objects created may look:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数有一个有趣的特性，就是它们只能具有私有访问权限。这意味着一个类可以提供自己的工厂方法（见[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)，*接口、类和对象构造*），控制每个对象如何构造，甚至控制可以将多少个对象放入循环中。在每个对象都需要访问某个资源（文件或另一个数据库）的情况下，最后一个特性尤为有价值，因为该资源对并发访问的支持有限。以下是这样一个具有限制创建对象数量的最简单版本的工厂方法的样子：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The usefulness of this code is not great and we show it only to demonstrate
    how a privately accessible constructor can be used. It is possible because each
    class members can access all other class members no matter their access modifiers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的用处不大，我们只是展示它来演示私有可访问构造函数的使用方式。这是可能的，因为每个类成员都可以访问所有其他类成员，无论它们的访问修饰符如何。
- en: All the accessibility-related features would be not needed unless they brought
    some advantages. And that is what we are going to talk about in the next section –
    about the central concept of object-oriented programming, called encapsulation,
    which would be impossible without accessibility control.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与可访问性相关的特性除非产生了一些优势，否则都不会被需要。这就是我们接下来要讨论的内容 - 关于面向对象编程的中心概念，称为封装，它是不可能没有可访问性控制。
- en: Encapsulation
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: The concept of OOP was born in an effort to manage the increasing complexity
    of software systems. The concept of data and procedures bundled in an object with
    controlled access to them (called encapsulation) allows better-organized data
    and procedures in layers, some of them hidden, others exposed to an access from
    outside. The accessibility control described in the previous sections was a significant
    part of it. Together with inheritance, interface (also called abstraction), and
    polymorphism, encapsulation became one of the central concepts of OOP.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的概念诞生于管理软件系统不断增加的复杂性的努力中。封装将数据和程序捆绑在一个对象中，并对它们进行了受控访问（称为封装），从而实现了更好地组织分层的数据和程序，其中一些隐藏，其他则可以从外部访问。前面部分描述的可访问性控制是它的重要部分之一。与继承、接口（也称为抽象）和多态性一起，封装成为面向对象编程的中心概念之一。
- en: There is often no clear-cut separation of one OOP concept from another. Interfaces
    help to hide (encapsulate) the implementation details too. Inheritance, with its
    ability to override and hide methods of the parent classes, adds a dynamic aspect
    to the accessibility. All these three concepts make it possible to add the concept
    of polymorphism—the ability of the same object to present itself as a different
    type, depending on the context (based on inheritance or an implemented interface),
    or change its behavior based on the data availability (using composition—we will
    talk about it in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles—*or method overloading, hiding, and overriding).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 往往没有一个面向对象编程的概念能清晰地与另一个分开。接口也有助于隐藏（封装）实现细节。继承可以覆盖和隐藏父类的方法，为可访问性增加了动态性。所有这三个概念使得可以增加多态性的概念
    - 相同的对象能够根据上下文呈现为不同类型（基于继承或已实现的接口），或者根据数据可用性改变其行为（使用组合 - 我们将在[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)中讨论，*面向对象设计(OOD)原则*或方法重载、隐藏和覆盖）。
- en: 'But none of the concepts would be possible without encapsulation. That is why
    it is the most fundamental among the four concepts of OOP. Chances are, you will
    hear it mentioned a lot, so we have decided to dedicate this section to the terms
    often used in the context of an encapsulation based on the advantages it provides:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果没有封装，上述任何一个概念都是不可能的。这就是为什么它是面向对象编程四个概念中最基本的概念。你可能会经常听到它被提到，所以我们决定专门讲解封装概念的术语及其提供的优势：
- en: Data hiding and decoupling
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据隐藏和解耦
- en: Flexibility, maintainability, refactoring
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性、可维护性、重构
- en: Reusability
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用性
- en: Testability
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Data hiding and decoupling
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据隐藏和解耦
- en: When we make object states (values of its fields) and some methods private or
    impose some other measure of restricted access to the internal object data, we
    participate in *data hiding*. The user of the object's functionality can call
    only certain methods based on their accessibility and cannot manipulate the object's
    internal state directly. The object's users may have no idea how exactly the functionality
    is implemented and the data is stored. They pass the required input data to the
    accessible methods and get back the results. This way we *decouple* the internal
    state from its usage and the implementation details from the API.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将对象状态（字段的值）和一些方法私有化或施加其他限制访问内部对象数据的措施时，我们参与了*数据隐藏*。对象功能的用户只能根据其可访问性调用特定方法，而不能直接操纵对象的内部状态。对象的用户可能不知道功能的具体实现方式和数据存储方式。他们将所需的输入数据传递给可访问的方法，并获得结果。这样，我们将内部状态与其使用和API的实现细节*解耦*了。
- en: Grouping related methods and data in the same class also increases *decoupling*,
    this time between different areas of functionality.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个类中将相关方法和数据分组也增加了*解耦*，这次是在不同功能的不同区域之间。
- en: You may hear the term *tightly coupled* as something that should be allowed
    only when there is no way to avoid it because it usually means that any change
    of one part would require a corresponding change of another part. Even in everyday
    life, we prefer to deal with modularized systems that allow replacing one module
    only without changing any other component of the rest of the system.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会听到密集耦合这个词，作为一种应该只在没有其他选择的情况下允许的东西，因为通常意味着更改一个部分就需要相应更改另一个部分。即使在日常生活中，我们也喜欢处理模块化的系统，允许只替换一个模块而不更改其余系统的任何其他组件。
- en: That is why *loose coupling* is usually something programmers prefer although
    it often comes at the price of not being sure that there will be no unexpected
    surprises until the system is tested in all possible execution paths. A well-thought-out
    system of tests that cover the essential use cases usually helps to reduce the
    chance of a defect propagation in production.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么程序员通常喜欢松散耦合，虽然这通常会以无法确定在所有可能的执行路径上都不存在意外惊喜的代价。一个经过深思熟虑的覆盖关键用例的测试系统通常有助于降低缺陷在生产中传播的可能性。
- en: Flexibility, maintainability, and refactoring
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活性、可维护性和重构
- en: When we talked about decoupling in the previous section, the idea of flexibility
    and maintainability probably came to mind by association. Loosely coupled systems
    are more flexible and easier to maintain.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们谈到解耦时，灵活性和可维护性的想法可能会因为联想而产生。松散耦合的系统更加灵活和易于维护。
- en: 'For example, in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Object Construction*, we demonstrated a flexible solution when implementing
    an object factory:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中，*接口、类和对象构造*，我们演示了一种灵活的解决方案来实现对象工厂：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is tightly coupled with its `Calculator` interface (its API) only, but that
    is inevitable because it is the contract the implementation must honor. As for
    the implementation inside the factory, it is much freer from any restrictions
    as long as it adheres to the contract.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它与其 `Calculator` 接口（其API）紧密耦合，但这是不可避免的，因为它是实现必须遵守的协议。至于工厂内部的实现，只要它遵循协议就可以更自由地从任何限制中脱颖而出。
- en: 'We could create an instance of each of the implementations only once and return
    only that one instance (making each class a singleton). Here is an example of
    `CalculatorImpl` as a singleton:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能创建实现的每个实例一次，并只返回那个实例（使每个类成为单例）。以下是以单例模式实现 `CalculatorImpl` 的示例：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or we could add another `Calculator` implementation to the factory as a nested
    class and use it instead of `CalculatorImpl`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以在工厂中添加另一个 `Calculator` 实现作为嵌套类，并使用它来替代 `CalculatorImpl`：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And the client code of this factory would never know the difference unless it
    prints out information about the class using the `getClass()` method on the object
    returned from the factory. But that is another story. Functionally, our new implementation
    of `Whatever` would work as an old one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂的客户端代码不会发现任何区别，除非它在从工厂返回的对象上使用 `getClass()` 方法打印有关类的信息。但这是另一件事情。从功能上讲，我们的新实现 `Whatever` 将像旧实现一样工作。
- en: 'And that is actually a common practice—to change internal implementation from
    one release to another. There are bug fixes, of course, and new functionality
    added. And as the code of the implementation is evolving, its programmers are
    constantly watching for the possibility of refactoring. In computer science, factoring
    is a synonym of decomposition, which is breaking a complex code into simpler parts
    with the purpose of making the code more readable and maintainable. For example,
    let''s assume we were asked to write a method that accepts two parameters of the `String`
    type (each represents an integer) and returns their sum as an integer too. After
    thinking for a moment, we decided to do it this way:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是一个常见的做法，可以在一个发布版中从一个内部实现改变到另一个。当然会有漏洞修复和新功能添加。随着实现代码的不断发展，其程序员会不断地关注重构的可能性。在计算机科学中，Factoring是Decomposition的同义词，Decomposition是将复杂代码拆分为更简单的部分的过程，以使代码更易于阅读和维护。例如，假设我们被要求编写一个方法，该方法接受 `String` 类型的两个参数（每个参数都表示一个整数），并将它们相加作为一个整数返回。经过一番思考，我们决定这样做：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But then we have asked for a sample of possible input values, so we can test
    our code in the condition close to production. It turned out that some of the
    values can be up to 10,000,000,000, which exceeds 2,147,483,647 (the maximum `Integer.MAX_VALUE` int
    value Java allows). So we have changed our code to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后我们要求提供可能输入值的样本，这样我们就可以在接近生产条件的情况下测试我们的代码。结果发现，一些值可以高达10,000,000,000，这超过了2,147,483,647（Java允许的最大`Integer.MAX_VALUE`整数值）。因此，我们已经将我们的代码更改为以下内容：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now our code can handle values up to 9,223,372,036,854,775,807 (which is `Long.MAX_VALUE`).
    We deployed the code to production and it worked just fine for several months,
    used by a big software system that processes statistics. Then the system switched
    to a new source of data and the code started breaking. We investigated and found
    out that a new source of data yields values that can include letters and some
    other characters. We have tested our code for such cases and discovered that the
    following line throws `NumberFormatException`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的代码可以处理高达9,223,372,036,854,775,807的值（这是`Long.MAX_VALUE`）。我们将代码部署到生产环境，并且在几个月内一直运行良好，被一个处理统计数据的大型软件系统使用。然后系统切换到了新的数据源，代码开始出现问题。我们进行了调查，发现新的数据源产生的值可以包含字母和一些其他字符。我们已经测试了我们的代码以处理这种情况，并发现以下行抛出`NumberFormatException`：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We discussed the situation with the domain experts and they suggested we record
    the values that are not integer, skip them, and continue the sum calculations.
    So, we have fixed our code, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与领域专家讨论了情况，他们建议我们记录不是整数的值，跳过它们，并继续进行求和计算。因此，我们已经修复了我们的代码，如下所示：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have quickly released the code to production, but for the next release got
    new requirements: the input `String` values can contain decimal numbers. So, we
    have changed the way we process the input `String` values by assuming they carry
    decimal values (which cover integer values too) and refactored the code, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迅速将代码发布到生产环境，但是在下一个发布中获得了新的要求：输入的`String`值可以包含小数。因此，我们已经改变了处理输入`String`值的方式，假设它们带有小数值（这也包括整数值），并重构了代码，如下所示：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That is what refactoring does. It restructures the code without changing its
    API. As new requirements keep coming in, we can change the `getLong()` method
    without even touching the `sum()` method. We also can reuse the `getLong()` method
    in other places, and that is going to be the topic of the next section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是重构所做的事情。它重新构造了代码而不改变其API。随着新的需求不断出现，我们可以修改`getLong()`方法，甚至不用触及`sum()`方法。我们还可以在其他地方重用`getLong()`方法，这将是下一节的主题。
- en: Reusability
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用性
- en: 'Encapsulation definitely makes it easier to achieve reusability because it
    hides the implementation details. For example, the `getLong()` method we wrote
    in the previous section can be reused by another method of the same class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 封装绝对使得实现可重用性变得更容易，因为它隐藏了实现细节。例如，在前一节中我们编写的`getLong()`方法可以被同一类的另一个方法重用：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It can even be made public and used by other classes, like in the following
    line:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至可以被公开并被其他类使用，就像下面的代码一样：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That would be an example of a composition when some functionality is built
    (composed) using methods of different classes not related by inheritance. And,
    since it does not depend on the object state (such a method is called stateless),
    it can be made static:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个组合的例子，当某些功能是使用不相关的类的方法（通过组合）构建时。而且，由于它不依赖于对象状态（这样的方法称为无状态），因此它可以是静态的：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Well, if the method is used concurrently by several other methods at runtime,
    even such a simple code may need to be protected (synchronized) against parallel
    usage. But such considerations are outside of the scope of this book. For now,
    if in doubt, do not make the method static.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该方法在运行时由多个其他方法同时使用，甚至这样一个简单的代码也可能需要受到保护（同步），防止并行使用。但是这样的考虑超出了本书的范围。如果有疑问，请不要使方法静态。
- en: If you read about the history of object-oriented programming, you will find
    that inheritance was originally tasked, among other things, to be the primary
    mechanism of code reuse. And it does the job. A child inherits (reuses) all the
    methods of its parent and overrides only those that need to be overridden for
    the child's specialization.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读面向对象编程的历史，您会发现继承最初被赋予了，除其他外，成为代码重用的主要机制。而它确实完成了任务。子类继承（重用）了其父类的所有方法，并且只覆盖那些需要为子类专业化的方法。
- en: But in practice, it seems that other reusability techniques, similar to those
    demonstrated earlier, are more popular, especially for cases when the reused method
    is stateless. We will talk more about the reasons for that in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但在实践中，似乎其他重复使用技术更受欢迎，尤其是对于重复使用的方法是无状态的情况。我们将在[第 8 章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)中更详细地讨论这一原因，*面向对象设计（OOD）原则*。
- en: Testability
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可测试性
- en: Code testability is another area where encapsulation helps. If the implementation
    details were not hidden, we would need to test every single line of code and change
    the test every time we change any line of the implementation. But hiding the details
    behind the facade of the API allows us to focus only on the test cases that are
    required and limited by the set of possible input data (parameter values).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可测试性是另一个封装有所帮助的领域。如果实现细节没有被隐藏，我们就需要测试每一行代码，并且每次更改实现中的任何行时都需要更改测试。但是，隐藏细节在
    API 外观后面允许我们仅专注于所需的测试用例，并且受可能输入数据集（参数值）的限制。
- en: Also, there are frameworks that allow us to create an object that returns a
    certain result based on the certain value of the input parameters. Mockito is
    a popular framework that does it ([http://site.mockito.org](http://site.mockito.org)).
    Such objects are called mock objects. They are especially helpful when you need
    to get certain results from methods of one object to test other methods, but you
    cannot run the actual implementation of the methods you use as the source of data
    because you do not have the necessary data in the database, for example, or it
    requires some complicated setup. To get around the problem, you can replace the
    actual implementation of certain methods—mock them—with one that returns the data
    you need unconditionally or in response to certain input data. Without the encapsulation,
    such simulation of a method behavior may be impossible because the client code
    would be tied to the specific implementation and you would not be able to change
    it without changing the client code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些框架允许我们创建一个对象，根据输入参数的特定值返回特定结果。Mockito 是一个流行的框架，它可以做到这一点（[http://site.mockito.org](http://site.mockito.org)）。这样的对象称为模拟对象。当您需要从一个对象的方法中获取特定结果以测试其他方法时，它们特别有帮助，但您不能运行作为数据源的方法的实际实现，因为您没有必要的数据在数据库中，例如，或者它需要一些复杂的设置。为了解决这个问题，您可以用返回您需要的数据的实际实现替换某些方法的实际实现——模拟它们，无条件地或以对某些输入数据做出响应。没有封装，这样模拟方法行为可能是不可能的，因为客户端代码将与特定实现绑定，您将无法在不更改客户端代码的情况下更改它。
- en: Exercise – Shadowing
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 - 遮蔽
- en: Write the code that demonstrates variable shadowing. We have not talked about
    it, so you will need to do some research.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编写演示变量遮蔽的代码。我们还没有讨论过它，所以您需要做一些研究。
- en: Answer
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: 'Here is one possible solution:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可能的解决方案：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you run `new ShadowingDemo().printX();`, it will print `x` first, then `y` because
    the local variable `x` in the following line shadows the `x` instance variable:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行 `new ShadowingDemo().printX();`，它将首先打印 `x`，然后打印 `y`，因为以下行中的局部变量 `x` 遮蔽了
    `x` 实例变量：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Please note that shadowing can be a source of a defect or can be used for the
    benefit of the program. Without it, you would be not able to use a local variable
    identifier that is already used by an instance variable. And here is another example
    of a case where variable shadowing helps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，遮蔽可能是缺陷的源泉，也可能有益于程序。如果没有它，您将无法使用已经被实例变量使用的局部变量标识符。这里还有另一个案例的例子，变量遮蔽有助于：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `x` local variable (parameter) shadows the `x` instance variable. It allows
    using the same identificator for a local variable name that has been already used
    for an instance variable name. To avoid possible confusion, it is recommended
    to refer to an instance variable using the keyword `this` as we did in the example
    above.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 局部变量（参数）遮蔽了 `x` 实例变量。它允许使用相同的标识符来命名一个局部变量，该标识符已经被用于实例变量名。为了避免可能的混淆，建议使用关键字
    `this` 引用实例变量，就像我们在上面的示例中所做的那样。'
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about one of the fundamental features of an object-oriented
    language – the rules of accessibility of classes, interfaces, their members, and
    constructors. You now can import classes and interfaces from other packages and
    avoid using their fully qualified names. All that discussion allowed us to introduce
    the central concept of OOP—encapsulation. With that, we can start an informed
    discussion of **object-oriented design** (**OOD**) principles.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你了解了面向对象语言的一个基本特性——类、接口、它们的成员和构造函数的可访问性规则。现在你可以从其他包中导入类和接口，并避免使用它们的完全限定名。所有这些讨论使我们能够介绍面向对象编程的核心概念——封装。有了这个，我们就可以开始对**面向对象设计**（**OOD**）原则进行有根据的讨论。
- en: The next chapter presents a higher-level view of Java programming. It discusses
    the criteria of a good design and provides a guide to the well-proven OOD principles.
    Each of the design principles is described in detail and illustrated using a corresponding
    code example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍了 Java 编程的更高层次视角。它讨论了良好设计的标准，并提供了一份对经过验证的 OOD 原则的指南。每个设计原则都有详细的描述，并使用相应的代码示例进行了说明。
