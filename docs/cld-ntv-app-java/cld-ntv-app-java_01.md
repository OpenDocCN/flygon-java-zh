# 第一章：贡献者

# 本书涵盖了什么

第一章，*云原生简介*，介绍了云原生应用程序的什么和为什么：是什么驱使应用程序转移到云端？为什么云开发和部署与常规应用程序不同？什么是 12 要素应用程序？

第二章，*编写您的第一个云原生应用程序*，介绍了使用微服务方法进行应用程序设计的核心概念。然后展示了一个样本的`product`服务，随着书中讨论的进行，它将被增强。您将学习如何使用 Spring Boot 进行微服务应用程序开发，并了解用于构建云原生应用程序的微服务原则。

第三章，*设计您的云原生应用程序*，涵盖了设计云原生应用程序时的一些高级架构考虑因素。它包括事件驱动架构、使用编排进行解耦，以及使用**领域驱动设计**（**DDD**）概念，如有界上下文。您将了解在云上开发和使用面向消费者友好的 API 来前端化应用程序的架构模式和考虑因素，而不是以系统为中心的服务定义。

第四章，*扩展您的云原生应用程序*，深入探讨了使用各种堆栈、原则和支持组件创建应用程序。它涵盖了在实现服务时的模式。本章重点介绍了差异化方面，如错误处理和**命令查询响应分离**（**CQRS**）和缓存等模式，这些模式对云开发有重大影响。

第五章，*测试云原生应用程序*，深入探讨了如何测试您的微服务以及如何使用**行为驱动开发**编写测试。

第六章，*云原生应用部署*，深入探讨了微服务的部署模型，包括如何将应用程序打包到 Docker 容器中，并设置 CI/CD 流水线。

第七章，*云原生应用程序运行时*，涵盖了服务的运行时方面。我们将介绍如何将配置外部化到配置服务器，并由 Zuul（Edge）前端化。我们将研究 Pivotal Cloud Foundry 并在 PCF Dev 上部署我们的服务。我们还将涵盖容器编排。

第八章，*平台部署 - AWS*，描述了 AWS 环境，并讨论了使用早期章节中讨论的概念（注册表、配置、日志聚合和异步消息传递）进行云开发的 AWS 特定工具。

第九章，*平台部署 - Azure*，描述了 Azure 环境，并讨论了用于进行云开发的 Azure 特定工具（包括 Service Fabric 和 Cloud Functions）。

第十章，*作为服务集成*，讨论了各种类型的 XaaS，包括 IaaS、PaaS、iPaaS 和 DBaaS，以及如何将基础设施元素暴露为服务。在云原生模式下，您的应用程序可能正在集成社交媒体 API 或 PaaS API，或者您可以托管其他应用程序将使用的服务。本章涵盖了如何连接/使用其他外部服务或提供此类服务。

第十一章，*API 设计最佳实践*，讨论了如何设计以消费者为中心的细粒度和功能导向的 API。它还讨论了 API 设计中的各种最佳实践，比如在 API 层级还是在服务中进行编排，如何创建 API 的免费版本，如何在 API 层面解决特定渠道的问题，以使服务保持渠道无关，以及 API 设计中的安全性方面。

第十二章，*数字化转型*，涵盖了云开发对企业现有格局的影响，以及如何实现转型迈向数字化企业。

# 关于作者

**Ajay Mahajan**是 Wipro Technologies 的杰出技术人员（DMTS），目前担任零售垂直领域的首席技术专家。在他目前的角色中，他帮助客户采用云原生和数字架构来开发下一代零售应用程序。他曾与欧洲和美国的零售和银行客户合作开发大规模的关键任务系统。在过去 19 年的 Java 平台工作中，他见证了企业 Java 从 Netscape 应用服务器到 servlets/JSP，JEE，Spring，以及现在的云和微服务的演变。

这本书中的许多想法、最佳实践和模式都源自我们在新兴技术领域的工作，该工作由 Aravind Ajad Yarra 领导。我特别感谢共同作者 Shyam，他是我遇到的最有才华的技术人员。特别感谢 Munish 对本书结构和内容的头脑风暴。我要感谢 Hari Burle，他的鼓励和指导帮助我专注于这本书。

**Munish Kumar Gupta**是 Visa 的首席系统架构师。他的日常工作涉及具有严格非功能性要求的应用程序解决方案架构、应用程序性能工程、应用程序基础设施管理，以及探索尖端开源技术在企业中的可采用性。他是*Akka Essentials*的作者。他对软件编程和工艺非常热衷。他在技术趋势、应用程序性能工程和 Akka 方面撰写博客。

我必须首先感谢我的妻子 Kompal。她督促我继续写作，现在我有了第二本书。感谢 Packt 团队的每个人对我的帮助。特别感谢 Zeeyan、Nitin 和 Romy。

**Shyam Sundar**是 Wipro Technologies 位于班加罗尔的高级架构师。他是 Wipro 新兴技术架构组的一员。他负责帮助团队在项目中采用新兴技术。他主要关注客户端和云技术。他是一个终身学习者，非常关心软件工艺。他不断尝试新的工具和技术，以改善开发体验。

我首先要感谢我的共同作者 Ajay 和 Munish，让我与他们一起踏上这不可思议的旅程。作为一个更习惯于用代码而不是文字表达自己的人，Ajay 和 Munish 给了我很多关于如何构建内容和简化概念的深思熟虑的建议。我还必须感谢我的老板 Aravind Ajad Yarra，他一直支持和鼓励我。

# 关于审阅者

Andreas Olsson 是 Java 和 Spring 培训师，专门从事云原生解决方案。他自 2001 年以来一直是 Java 开发人员，并于 2004 年开始使用 Spring。在设计应用程序架构时，他通常会在 Spring 生态系统中找到解决方案。2011 年，云原生平台开始出现时，他成立了自己的公司，自那时起一直是云原生的爱好者。Andreas 居住在瑞典，目前在国际上担任培训师。他是一名经过认证的 Java 和 Spring 专业人员，非常喜欢每天学习新东西。

# Packt 正在寻找像您这样的作者

如果您有兴趣成为 Packt 的作者，请访问[authors.packtpub.com](http://authors.packtpub.com)并立即申请。我们已经与成千上万的开发人员和技术专业人士合作，就像您一样，帮助他们与全球技术社区分享见解。您可以进行一般申请，申请我们正在招聘作者的特定热门主题，或者提交您自己的想法。

# 目录

1.  标题页

1.  版权和鸣谢

1.  Java 中的云原生应用程序

1.  致谢

1.  Packt 升级

1.  为什么订阅？

1.  PacktPub.com

1.  前言

1.  贡献者

1.  关于作者

1.  关于审阅者

1.  Packt 正在寻找像您这样的作者

1.  前言

1.  这本书是为谁准备的

1.  本书涵盖了什么

1.  充分利用本书

1.  下载示例代码文件

1.  下载彩色图像

1.  使用的约定

1.  联系我们

1.  评论

1.  云原生简介

1.  为什么选择云原生？

1.  什么是云原生？

1.  提升和转移

1.  本地化

1.  无服务器化

1.  云原生和微服务

1.  12 要素应用程序

1.  微服务启用服务生态系统

1.  微服务采用

1.  单体转换

1.  总结

1.  编写您的第一个云原生应用程序

1.  设置您的开发人员工具箱

1.  获取 IDE

1.  设置互联网连接

1.  了解开发生命周期

1.  要求/用户故事

1.  架构

1.  设计

1.  测试和开发

1.  构建和部署

1.  选择框架

1.  Dropwizard

1.  Vert.x

1.  Spring Boot

1.  编写产品服务

1.  创建 Maven 项目

1.  编写 Spring Boot 应用程序类

1.  编写服务和域对象

1.  运行服务

1.  在浏览器上测试服务

1.  创建可部署的

1.  启用云原生行为

1.  外部配置

1.  计量您的服务

1.  服务注册和发现

1.  运行服务注册表

1.  注册产品服务

1.  创建产品客户端

1.  看查找操作

1.  总结

1.  设计您的云原生应用程序

1.  三重奏 - REST、HTTP 和 JSON

1.  API 的崛起和流行

1.  API 网关的作用

1.  API 网关的好处

1.  应用程序解耦

1.  有界上下文/领域驱动设计

1.  分类为上游/下游服务

1.  业务事件

1.  微服务识别

1.  微服务和面向服务的架构（SOA）之间的区别

1.  服务粒度

1.  微服务设计准则

1.  设计和部署模式

1.  设计模式

1.  内容聚合模式

1.  客户端聚合

1.  API 聚合

1.  微服务聚合

1.  数据库聚合

1.  协调模式

1.  业务流程管理（BPM）

1.  复合服务

1.  为什么要使用复合服务？

1.  微服务协调的能力

1.  协调模型

1.  异步并行

1.  异步顺序

1.  使用请求/响应进行编排

1.  折叠微服务

1.  部署模式

1.  WAR 文件中的多个服务

1.  利弊

1.  适用性

1.  每个 WAR/EAR 服务

1.  利弊

1.  适用性

1.  每个进程的服务

1.  利弊

1.  适用性

1.  每个 Docker 容器的服务

1.  利弊

1.  适用性

1.  每个 VM 的服务

1.  利弊

1.  适用性

1.  每个主机的服务

1.  利弊

1.  适用性

1.  发布模式

1.  微服务的数据架构

1.  命令查询责任分离（CQRS）

1.  复制数据

1.  好处

1.  缺点

1.  适合目的

1.  安全的作用

1.  摘要

1.  扩展您的云原生应用程序

1.  实施获取服务

1.  简单的产品表

1.  运行服务

1.  传统数据库的局限性

1.  缓存

1.  本地缓存

1.  在幕后

1.  本地缓存的局限性

1.  分布式缓存

1.  应用 CQRS 以分离数据模型和服务

1.  关系数据库上的物化视图

1.  Elasticsearch 和文档数据库

1.  为什么不仅使用文档数据库或 Elasticsearch？

1.  核心产品服务在文档数据库上

1.  准备好使用测试数据的 MongoDB

1.  创建产品服务

1.  拆分服务

1.  产品搜索服务

1.  准备好使用测试数据的 Elasticsearch

1.  创建产品搜索服务

1.  数据更新服务

1.  REST 约定

1.  插入产品

1.  测试

1.  更新产品

1.  测试

1.  删除产品

1.  测试

1.  缓存失效

1.  验证和错误消息

1.  格式验证

1.  数据验证

1.  业务验证

1.  异常和错误消息

1.  CQRS 的数据更新

1.  异步消息传递

1.  启动 ActiveMQ

1.  创建主题

1.  Golden source update

1.  服务方法

1.  数据更新时触发事件

1.  使用 Spring JMSTemplate 发送消息

1.  查询模型更新

1.  插入、更新和删除方法

1.  端到端测试 CQRS 更新场景

1.  摘要

1.  测试云原生应用

1.  在开发之前编写测试用例

1.  TDD

1.  BDD

1.  测试模式

1.  A/B 测试

1.  测试替身

1.  测试存根

1.  模拟对象

1.  模拟 API

1.  测试类型

1.  单元测试

1.  集成测试

1.  负载测试

1.  回归测试

1.  确保代码审查和覆盖率

1.  测试产品服务

1.  通过 Cucumber 进行 BDD

1.  为什么选择 Cucumber?

1.  Cucumber 是如何工作的？

1.  Spring Boot 测试

1.  使用 JaCoCo 进行代码覆盖

1.  集成 JaCoCo

1.  摘要

1.  云原生应用部署

1.  部署模型

1.  虚拟化

1.  PaaS

1.  容器

1.  Docker

1.  构建 Docker 镜像

1.  Eureka 服务器

1.  产品 API

1.  连接到外部的 Postgres 容器

1.  部署模式

1.  蓝绿部署

1.  金丝雀部署

1.  暗部署

1.  应用 CI/CD 进行自动化

1.  摘要

1.  云原生应用运行时

1.  运行时的需求

1.  实现运行时参考架构

1.  服务注册表

1.  配置服务器

1.  配置服务器的服务器部分

1.  配置客户端

1.  刷新属性

1.  微服务前端

1.  Netflix Zuul

1.  幕后发生了什么

1.  同时运行它们

1.  Kubernetes - 容器编排

1.  Kubernetes 架构和服务

1.  Minikube

1.  在 Kubernetes 中运行产品服务

1.  平台即服务（PaaS）

1.  PaaS 的案例

1.  Cloud Foundry

1.  组织、账户和空间的概念

1.  Cloud Foundry 实现的需求

1.  Pivotal Cloud Foundry (PCF)

1.  PCF 组件

1.  PCF Dev

1.  安装

1.  启动 PCF Dev

1.  在 PCF 上创建 MySQL 服务

1.  在 PCF Dev 上运行产品服务

1.  部署到 Cloud Foundry

1.  摘要

1.  平台部署 - AWS

1.  AWS 平台

1.  AWS 平台部署选项

1.  将 Spring Boot API 部署到 Beanstalk

1.  部署可运行的 JAR

1.  部署 Docker 容器

1.  将 Spring Boot 应用程序部署到弹性容器服务

1.  部署到 AWS Lambda

1.  摘要

1.  平台部署 - Azure

1.  Azure 平台

1.  Azure 平台部署选项

1.  将 Spring Boot API 部署到 Azure App Service

1.  将 Docker 容器部署到 Azure 容器服务

1.  将 Spring Boot API 部署到 Azure Service Fabric

1.  基本环境设置

1.  打包产品 API 应用程序

1.  启动 Service Fabric 集群

1.  将产品 API 应用程序部署到 Service Fabric 集群

1.  连接到本地集群

1.  连接到 Service Fabric party 集群

1.  Azure 云函数

1.  环境设置

1.  创建新的 Java 函数项目

1.  构建和运行 Java 函数

1.  深入代码

1.  摘要

1.  作为服务集成

1.  XaaS

1.  构建 XaaS 时的关键设计问题

1.  与第三方 API 集成

1.  摘要

1.  API 设计最佳实践

1.  API 设计关注点

1.  API 资源识别

1.  系统 API

1.  过程 API

1.  通道 API

1.  API 设计指南

1.  命名和关联

1.  资源的基本 URL

1.  处理错误

1.  版本控制

1.  分页

1.  属性

1.  数据格式

1.  客户端支持有限的 HTTP 方法

1.  身份验证和授权

1.  端点重定向

1.  内容协商

1.  安全

1.  API 建模

1.  开放 API

1.  RESTful API 建模语言（RAML）

1.  API 网关部署模型

1.  摘要

1.  数字转型

1.  应用程序组合理性化

1.  投资组合分析 - 业务和技术参数

1.  退休

1.  保留

1.  巩固

1.  转换

1.  单体应用转换为分布式云原生应用

1.  将单体应用转换为分布式应用

1.  客户旅程映射到领域驱动设计

1.  定义架构跑道

1.  开发者构建

1.  打破单体应用

1.  将所有内容整合在一起

1.  构建自己的平台服务（控制与委托）

1.  摘要

1.  您可能喜欢的其他书籍

1.  留下评论-让其他读者知道您的想法
