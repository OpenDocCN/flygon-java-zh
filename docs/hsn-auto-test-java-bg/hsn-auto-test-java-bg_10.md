# final 关键字、包和修饰符的重要性

这是我们书中的最后一章。在这里，我们将处理一些更重要的概念，这些概念将帮助我们编写和执行更好的代码。

在本章中，我们将讨论以下概念：

+   final 关键字

+   包

+   Java 中的修饰符

# final 关键字

首先，我们将创建一个新类。如果我们将任何变量声明为`final`，那意味着该值不能再次更改。让我们考虑以下代码：

```java
package coreJava;

public class finaldemo {

    public static void main(String[] args) {
        //TODO Auto-generated method stub
        final int i=4; //constant variables
    }
}
```

正如你所看到的，我们已将整数值声明为`4`。这意味着我们不能将这个值更改为另一个数字。如果我们尝试这样做，它会抛出一个错误，说`Remove 'final' modifier of 'i'`。如果我们希望一个值是常量，这个关键字是有用的。

如果我们将一个类标记为`final`，它会抛出一个错误，因为当我们将访问模式更改为`final`时，我们无法将其用作父类。换句话说，我们将无法从中继承我们的属性。如果我们想要继承我们的属性，我们需要将其改回`public`。final 关键字的关键逻辑是，一旦编写，我们就无法覆盖`final`方法。因此，这些是独一无二的，不能再次使用相同的名称。

final 关键字可以用于方法级别，以确保该方法不被覆盖。它用于变量级别，以确保我们不会更改它，还可以用于类级别，以确保我们不会继承该父类。

但是记住不要混淆`final`和`finally`。`finally`与`try...catch`异常有关。一旦执行`try`或`catch`块，并预先任何错误，控制器仍将来到此日志并执行代码，无论脚本是通过还是失败。`finally`是关于限制访问的，例如我们不能使用它，继承它，甚至更改值。我们已经探讨了包，以及如何将包导入其他类。我们已经探讨了接口的继承，运行时多态，字符串等等。这都是关键字。

在下一节中，我们将学习有关包的知识。

# 包

当为每个 Java 类编写脚本时，会自动出现一个预填的行。它是`package coreJava`。由于我们在 Java 中创建了一个包，并将所有 Java 类放入了`coreJava`包中，我们将其视为`package coreJava`。

包只是一组类和接口。例如，Java 自带了一些内置包，比如`java.length`；如果我们导入这个包，那么我们只能访问基本的基本方法，比如`public static void main`，整数或数组。所有这些类都来自`java.lang`包。定义包名很重要，因为没有它，我们无法访问包内的类。这是因为`java.lang`是一个默认包，它包含在 Java 编译器中。

我们还有另一个包，`java.util`。我们在处理集合时使用了这个包；我们导入了一个`java.util`包。为了使用`ArrayList`，这个类存在于`java.util`包中。因此，如果我们移除`import java.util.ArrayList`，它会抛出一个错误，因为它不属于`java.lang`。所有集合接口都来自`util`包。

但是我们如何知道要使用什么关键字？以下屏幕截图显示了当我们将鼠标悬停在 Eclipse 上时 Eclipse 会显示什么：

![](img/e544ea6b-85b3-4d6d-9a42-d78acde26018.png)

快速修复下拉菜单提供了纠正代码错误的建议

我们正在导入`java.util`包。并且从该包中，我们正在导入`ArrayList`类。其语法将是：

```java
import package.classname
```

在这里，我们在这个 Java 类中使用`ArrayList`的原因是因为我们知道`ArrayList`在`java.util`包中。但是在使用 Eclipse 时，我们不需要记住它。当你只是悬停鼠标时，它会建议我们导入包，我们只需点击它。它将自动导入那个特定的测试。

`HashSet`从同一个`util`包中导入了`HashSet`类。如果我们去`HashMap`，它会带来`HashMap`。因此，每当我们想要处理一些测试时，我们需要导入那个包或类。`System.out.println()`也只来自一个包，但它们来自`java.lang`，这是一个内置的编译器。这些都是 Java 包内置的。

同时，我们也可以定义一个用户定义的 Java 包。在这种情况下，我们所有的测试用例都在一个名为`coreJava`的不同包中。如果有人想要使用我们的类，他们只需要运行`import coreJava.classname`。

在下一节中，我们将看一下 public 修饰符。

# Java 中的修饰符

有四种类型的访问修饰符：

+   `public`

+   `private`

+   `protected`

+   `default`

我们不会在这里讨论理论，因为你可以在 Google 上找到。我们需要一个实际的方法，来看看这些访问修饰符到底在哪里使用，或者包到底在哪里导入。每当我们在这本书中创建一个方法时，我们都只是使用`public`并写下这个方法。其他三种访问修饰符的工作方式也类似。

现在让我们试着理解每种访问修饰符如何帮助我们。

# default

如果我们没有提及任何访问修饰符，我们的 Java 类会自动认为它有一个`default`访问修饰符。如果是`default`，那意味着你可以在你的包中的任何地方访问这个方法。但是如果你离开了这个包，那么你就无法访问这个方法。即使我们将`package.classname`导入到我们的新包中，如果我们没有将其指定为`public`，我们也无法访问这个方法。如果你不指定它，那么默认它认为它是一个`default`访问修饰符。`default`访问修饰符可以在包中的任何地方访问，但在包外部不能访问。

在*Packages*部分，我们导入了这个包并尝试使用它。如下截图所示，第 15 行出现了一个错误：

![](img/d9dfca50-0720-409c-bd0f-5457b9af0d7a.png)

快速修复下拉菜单提供了默认代码错误的建议

如果我们不指定任何东西，我们就无法访问它，因此它与默认功能相同。这也适用于变量：

```java
public class arrayListexample {
    // can accept duplicate values
    //ArrayList, LinkedList, vector- Implementing List interface
    //array has fixed size where arraylist can grow dynamically
    //you can access and insert any value in any index
    int i=5;
```

正如我们所看到的，在前面的代码中我们声明了一个整数。然而，它不会是`public`；它是`default`。因此，我们无法在包外访问这个变量。如果我们导入它，我们将可以访问这个类但不能访问方法。如果我们想要访问，我们必须将其写为`public`。那么`public`访问修饰符是什么作用呢？

# public

将方法或变量设为`public`后，我们将可以在所有的包中访问它。这基本上意味着任何地方。对于这个类的这个包没有限制。在前面的截图中观察到的错误也会在我们将方法/变量设为`public`后消失。

在我们将其设为`public`后，下面的截图显示了`int`值：

![](img/cd7b7481-22ae-445e-bfb6-22257a6f5ef9.png)

快速修复下拉菜单提供了默认代码错误的建议

在下一个类中，我们将看一下`private`和`protected`访问修饰符是什么。在这之后还有两种访问修饰符，让我们看看它们的作用。

# private

如果我们将我们的方法或变量标记为`private`，那么我们就无法在类外访问它们。它们不能在包外或同一个类外被访问。如果我们想在我们的`ArraysDemo`示例中访问它，我们无法这样做。即使我们尝试，它也会抛出一个错误，如下截图所示：

![](img/50710110-dc12-4e9a-8739-6c1ace39fac8.png)

快速修复下拉菜单显示了一个建议，可以纠正私有代码错误

这是因为，如果我们将任何方法或变量标记为`private`，我们就无法在那个特定的类之外访问它。除非我们将它改为其他东西，否则会抛出错误。这也适用于变量。

如果你想要一个实时场景，比如你正在进行支付和购买产品；所有的信用卡细节都会被标记为`private`，因为它们不会在购买类之外被访问。如果它们可以被访问，那就是一个安全漏洞，对吧？所以为了让信用卡细节受限于那个特定的类，开发人员给所有的卡细节都加上了`private`变量，这样其他类就不能使用它。即使它们使用了继承或者导入了一个包，它们也无法访问这些敏感细节。有很多实时场景；如果你正在测试框架上工作，可能会有一些变量你不应该改变，并且总是保持它私有。

# protected

如果我们将一个变量或方法定义为`private`，我们只能在子类中访问它们。这意味着如果我们将它定义为`protected`；那么，无论哪个类继承了父类，只有这些子类才能访问该方法，其他类都不能。这可以通过以下代码片段来理解：

```java
protected void abc() {
    //TODO Auto-generated method stub
    System.out.println("Hello");
    }
```

`default`和`protected`之间的区别在于，在`default`中我们只能在同一个类包内访问一个类。即使`protected`可以访问同一个包内的所有类，除了它还有一个额外的特性。这个额外的特性是，如果我们想在其他包中访问它，只有继承父类属性的子类才能访问它。

相同的概念也适用于变量。

# 总结

在本章中，我们学习了帮助我们理解 Java 中包、修饰符和`final`关键字的重要性的概念。

希望你现在已经阅读了所有章节，对这些概念有了更好的理解。
