# 第六章：了解有关数组的一切

在本章中，我们将看一下 Java 代码中最重要的概念之一：数组。我们将看到不同的数组是如何样的，以及如何初始化和显示它们。我们还将看一些练习，以帮助我们更好地理解数组的工作原理。

我们将在本章中涵盖以下主题：

+   Java 程序中的数组及其用法

+   初始化数组和分配对象的方法

+   多维数组的逻辑编程

+   练习

# Java 程序中的数组及其用法

也许我们以前曾听说过数组这个术语，所以让我们看一下数组是什么，通过解释和一个例子。

数组是存储相同数据类型的多个值的容器。

在下面的例子中，我们将看到容器是什么，如何定义该容器，以及我们如何在其中存储值。

如果我们想要使用数组，我们可以使用以下代码为它们分配一些空间来声明它们：

```java
int a[] = new int[];
```

`new`关键字基本上为数组中的值分配内存。方括号表示我们正在将多个值添加到方括号中，`[]`表示数组的术语。要定义数组，我们必须为将要存储在其中的多个值创建空间。在这个例子中，我们计划存储在数组中的有五个整数值，这就是为什么我们指定了数组数据类型为整数，并且要添加的变量数量在方括号中给出：

```java
int a[] = new int[5];
```

正如我们在第三章中观察到的，*在 Java 中处理字符串及其函数*，如果值是字符串，我们将指定数组数据类型为`String`。

我们已经声明了一个数组并为值分配了内存，现在我们需要传递这些值。第一个值将被放在索引`0`中，第二个值将被放在索引`1`中，以此类推，对于所有五个值都是如此。索引命名从`0`索引开始，因此第一个值将被分配给`0`索引。这意味着我们实际上在数组中初始化了值。现在`a`数组包含了我们分配给它的所有值。对于我们的例子，我们为数组声明任意随机值。

现在让我们从数组中检索值。为此，我们在`main`类中声明数组的值后创建一个`for`循环，并在此之后留下一个打印语句：

```java
for(int i=0; i<a.length;i++);
{
    System.out.println(a[i]);
}
```

我们的起始点已经设置为索引`0`，限制已经设置为数组的长度。看一下`i<a.length`的代码，`length`是一个实际返回数组大小的方法。

在运行代码时，我们看到分配给数组的所有值都一个接一个地打印出来。在下一节中，我们将看到声明和初始化所有数组值的更简单的方法。

# 初始化数组和分配对象的方法

在上一节中，我们看到了如何声明数组；最简单的方法是以数组文字的形式。让我们用一个例子来解释这个。

我们通过在上一个例子中输入以下代码行来声明另一个数组：

```java
int b[] = {1,4,3,5,7,8};
```

在上一个例子中的声明和我们在这个例子中执行的声明之间有什么区别？

在上一个例子中，我们正在分配内存，然后赋值。在这个例子中，我们不是分配内存，而是直接将值传递给数组。在这里，内存是动态分配的，如果我们在数组声明中添加一个值，将自动分配内存并将值传递给它。在大多数情况下，编码人员使用这种方法来声明数组值，而不是声明分配然后赋值。

与上一个例子类似，第一个值分配给索引`0`。如果我们编写类似于上一个例子的打印语句并运行代码，我们将看到`b`数组的值被显示出来。

这就结束了单维数组；让我们谈谈多维数组。

# 多维数组

在*x*轴和*y*轴传递对象就是一个多维数组。其中*x*轴是行，*y*轴是矩阵中给定数组值的列。在这种情况下，multi 意味着我们从多个角度查看数组；这被称为**多维**数组。以下是我们创建的一个多维数组，用来解释这个概念：

```java
2  4  5
3  4  7
5  2  1
```

这是一个矩阵，它有三行三列。`2`在零行零列，旁边的`4`在零行第一列，其他值的迭代也是一样的。所以每个参数都有一个*x*轴和一个*y*轴。

让我们举个例子来解释这一点。我们将创建另一个类，命名为`Multidimensional.java`，并在其中声明一个多维数组`a`：

```java
int a[][] = new int[2][3];
```

第一个括号代表*x*轴或行，第二个代表*y*轴或列。因此，*x*轴有三个值，这意味着三行，*y*轴有三列。然后我们为我们创建的矩阵的每个元素分配值，以解释多维数组。以下代码显示了如何为矩阵分配值：

```java
a[0][0]=2;
a[0][1]=4;
a[0][2]=5;
a[1][0]=3;
a[1][1]=4;
a[1][2]=7;
```

这样我们将所有的值都输入到一个多维数组中。如果我们想要显示第二行第一列的值，我们写一个打印语句并给出我们想要显示的元素的位置。在这种情况下，我们想要显示第二行第一列，所以打印语句将写成：

```java
System.out.println(a[1][0]);
```

打印语句将显示`3`，这是该位置元素的值。在下一节中，我们将举一个例子来帮助解释如何在解决编码中使用所有这些概念。

我们如何打印在这个例子中声明的数组 a 的所有值？在之前的例子中，我们通过简单地创建一个`for`循环，将其迭代从`0`到数组的长度，并显示数组来打印数组。

如果我们想要以最简单的格式声明一个多维数组，就像在上一个例子中描述的数组`b`一样，我们可以按照以下方式写：

```java
int b[][]= {{2,4,5},{3,4,7},{5,2,1}};
```

数组将假定括号中的值在零索引中，第二个在第一个索引中，第三个在第二索引中。这是声明多维数组的最简单方式。

# 多维数组的逻辑编程

现在我们将看一下如何打印在上一节中使用的整个多维数组 a 的所有值。

如果我们分析数组的声明，我们会发现需要两个`for`循环来打印整个数组，一个用于行，一个用于列。

我们希望控制器扫描完整的第一行，然后是第二行，最后是第三行。因此，我们为行添加一个外部的`for`循环，并将长度限制设置为数组中的行数，在这种情况下是两行。行的外部`for`循环将如下所示：

```java
for(int i=0;i<2;i++)
```

这个`for`循环实际上会循环两次，因为我们为行设置了限制为`2`。第一个循环将扫描第一行，第二个循环将扫描第二行。现在对于每个循环，我们需要扫描该特定行中存在的三列。为此，我们添加一个内部的`for`循环，它将扫描每一列，并将限制设置为数组中的列数，对于这个例子来说是`3`。列的内部`for`循环将如下所示：

```java
for(int j=0;j<3;j++)
```

最后，为了打印数组，我们在内部的`for`循环中添加一个打印语句来显示所有的值。最终的代码将如下所示：

```java
for(int i=0;i<2;i++) //row
{
    for(int j=0;j<3;j++) //coloumn
    {
        System.out.println(a[i][j]);
    }
}
```

让我们试着理解我们在这里写的内容。控制将从外部的`for`循环开始；这个外部的`for`循环执行两次，因为它被设置为小于`2`。第一次进入外部的`for`循环后，它进入内部的`for`循环；这个循环执行三次，因为`j`被设置为小于`3`。

让我们调试一下，看一下代码中的一些步骤，以更好地理解这些循环。以下是在调试代码时将执行的步骤：

1.  控制器第一次执行外部循环，`i`的值已经初始化为`0`，这意味着*x*轴的值设置为`0`。控制器将查看第一行，因为`0`表示正在访问第一行。

1.  它移动到内部的`for`循环并执行它，`j`的初始值已经初始化为`0`；这意味着*y*轴的值被设置为`0`。控制器将查看第一行和第一列，因为它已经在第一行，由于外部循环。内部循环将控制器发送到第一列。

1.  `a`将取第一行和第一列的值，因为`i`和`j`的值被初始化为`0`，`a[0][0]`。因此，这次执行的输出将是第一行和第一列，在这个例子中是`2`。

1.  控制器再次移动到内部的`for`循环，因为循环的条件仍然满足，因为`j`被迭代为`1`，小于`3`；这意味着*y*轴的值被设置为`1`，它将访问第二列。控制器将查看第一行和第二列，因为它已经在第一行，由于外部循环和内部循环将控制器发送到第二列。

1.  `a`将取第一行和第二列的值，因为`i`和`j`的值设置为`0`和`1`，`a[0][1]`。因此，这次执行的输出将是第一行和第二列，在这个例子中是`4`。

1.  控制器再次移动到内部的`for`循环，因为循环的条件仍然满足，因为`j`被迭代为`2`，小于`3`。这意味着*y*轴的值被设置为`2`，它将访问第三列。控制器将查看第一行和第三列，因为它已经在第一行，由于外部循环和内部循环将控制器发送到第三列。

1.  `a`将取第一行和第三列的值，因为`i`和`j`的值设置为`0`和`2`，`a[0][2]`。因此，这次执行的输出将是第一行和第三列，在这个例子中是`5`。

1.  当控制器现在进入内部循环时，它将无法执行，因为`j`再次被迭代后的值将为`3`，这不小于我们为循环设置的限制。因此，控制器退出内部的`for`循环，回到外部循环，并将`i`的值迭代为`1`；这意味着*x*轴的值被设置为`1`。控制器将查看第二行，因为`1`表示正在访问第二行。

1.  步骤 2、3、4、5、6 和 7 再次重复，但这次*x*轴的值`i`被设置为`1`；这意味着将访问第二行。根据先前指定的步骤，显示第二行中的所有值，直到达到矩阵的第三列。

1.  控制器在访问第三列后退出内部循环，因为`j`将被迭代为`3`，小于我们为循环设置的限制。因此，控制器再次退出内部的`for`循环，并开始执行外部循环。

1.  在外部的`for`循环中，`i`的值将被迭代为`2`，并且循环不会被执行，因为它不小于`2`，这是我们为它设置的限制。

这就是使用两个`for`循环获取多维数组值的方式，其中外部循环处理行，内部循环处理列。

# 练习

让我们尝试一些练习，这些练习将帮助我们理解和处理数组。这些练习还将在面试时解释概念。

# 打印一个 3 x 3 矩阵中的最小数

让我们为这个练习创建另一个类，命名为`InterviewMinnumber`，并在主块中定义数组。定义代码将如下所示：

```java
int abc[][]={{2,4,5},{3,2,7},{1,2,9}};
```

这段代码声明了一个名为`abc`的 3x3 矩阵。现在我们需要遍历矩阵中的每个数字，并找到其中的最小数。为了遍历多维数组中的每个数字，我们需要使用我们在*多维数组上的逻辑编程*部分中使用的相同概念。

我们在这里使用两个`for`循环：一个外部的`for`循环用于遍历行，一个内部的`for`循环用于遍历列。两个`for`循环的代码将如下所示：

```java
for(int i=0;i<3;i++)
    {
    for(int j=0;j<3;j++)
    {
    }
}
```

为了找到最小数，我们声明一个变量`min`，并将`abc`数组的第一个值赋给它。我们假设`abc`矩阵中的第一个值是最小值。

我们在内部的`for`循环中添加一个`if`循环。在这个`if`循环中，无论我们写什么都将扫描我们声明的整个矩阵中的每个元素。在`if`循环中，我们添加一个条件，检查在那个实例从矩阵中取出的值是否小于`min`值。在`if`循环中，我们交换`min`和`abc`的值。最终的代码将如下所示：

```java
public class InterviewMinnumber 
{
    public static void main(String[] args) 
    {
        int abc[][]={{2,4,5},{3,2,10},{1,2,9}};
        int min=abc[0][0];
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(abc[i][j]<min)
                {
                    min=abc[i][j];
                }
            }
        }
        System.out.println(min)
    }
}
```

让我们运行代码，看看它是如何找到矩阵中的最小数的。

当循环第一次执行时，矩阵中的第一个元素的值与`min`变量的值进行比较，但我们将`min`变量的值设置为第一个元素的值，即`2`。我们检查`if`循环中的条件，它比较矩阵中的元素的值和`min`的值。这里，`2`不小于`2`，所以它不进入循环，而是再次回到代码的开始。在循环的下一轮中，元素的值会改变，因为我们移动矩阵中的下一个元素。现在被比较的元素是`4`，我们再次检查`if`条件，它不会成立，因为`4`不小于`2`，而`2`是`min`的当前值。最后，当它到达第三行第一列的元素`1`时，`if`条件成立，控制器进入循环并将`1`赋给`min`的值。这将一直持续到数组矩阵中的最后一个元素，其中`abc`矩阵的每个值都与`min`变量的值进行比较。

如果我们调试代码并观察每一步，我们将更好地理解这段代码的逻辑和工作原理。

# 显示最小数所在列的最大数

在上一个例子中，我们观察了如何打印数组矩阵中的最小数。在这个例子中，我们将寻找矩阵中的最小数，然后在同一列中寻找最大数。这背后的逻辑是：我们首先找到最小数，记住它所属的行号，然后提取同一列中的最大数。

让我们使用在上一个例子中使用的相同矩阵。我们使用的矩阵的输出将是`4`。以下步骤将被实施来执行这个练习：

1.  找到我们声明的矩阵中的最小值

1.  识别最小数的列

1.  找到已识别列中的最大数

我们已经在上一个例子中执行了第 1 步，在那里我们找到了矩阵中的最小数，所以我们将使用相同的代码来进行这个例子，只是稍微改变一下变量：

```java
int abc[][]={{2, 4, 5}, {3, 0, 7}, {1, 2, 9}}
```

让我们继续进行第 2 步。如果我们观察代码，我们会发现`i`代表行号，`j`代表列号。所以`j`将取得最小数所在的列的值，我们将这个`j`的值赋给一个名为`mincolumn`的变量。所以我们在交换命令下编写代码，将`j`的值赋给`mincolumn`。代码将看起来像这样：

```java
mincoloumn=j;
```

所以当我们在矩阵中找到最小的数字时，我们将其赋值为`j`的值，即`mincloumn`的列号。在这种情况下，`mincolumn`的值将是`1`。这就完成了第 2 步。

在第 3 步中，我们从包含最小数字的列中寻找最大数字。我们在外部创建了一个`while`循环，该循环是我们用来查找矩阵中最小数字的外部`for`循环。我们将条件变量`k`初始化为`0`，并在每次满足`while`循环条件时迭代它。`while`循环的条件设置为`k`小于`3`；这是因为我们有三行要遍历以查找它们中的最大值。`while`循环的代码如下：

```java
while(k<3)
{
    k++;
}
```

我们声明一个名为`max`的变量，并给它一个初始值，即第`0`行和第`mincolumn`列。这样一来，变量`max`的初始值将是`4`，因为`4`是矩阵中包含最小数字的行中的第一个元素。声明代码如下：

```java
int max=abc[0][mincoloumn];
```

在`while`循环中，我们添加了一个`if`循环，并设置了一个条件，比较具有最小数字的列中的变量是否大于我们声明的变量`max`。如果条件满足，该数字的值将被赋给`max`变量，并且控制器在迭代`k`加`1`后从`if`循环中移出，并返回到`while`循环。迭代将使控制器转到下一行，因为`k`用于表示正在遍历以查找最大数字的行。

`if`循环的代码如下：

```java
if(abc[k][mincoloumn]>max)
{
    max=abc[k][mincoloumn];
}
```

因此，对于`k`的第一个值，即`0`，我们转到第一行和第二列，并将值赋给`max`；在这个例子中，值为`4`。在`if`条件中，我们将第一行第二列的值与`max`的值进行比较。在这个例子中，两个值是相同的，所以`if`循环不会被执行，我们迭代`k`并再次进入`while`循环。接下来，我们将第二行第二列的值与`max`的值进行比较；我们转到第二行，因为`k`的值被迭代了`1`，当前的`k`值是`1`。因此，在比较时，我们发现`o`小于`4`，其中`4`是`max`变量的值。条件再次不满足，`if`循环再次被跳过。这对于第三行也是一样的，`max`的最终值是`4`，这是该列中最大的数字。最后，我们留下一个打印语句来打印`max`的值。

# 使用/不使用临时变量交换变量

在这个练习中，我们将交换简单数组中元素的位置，并将它们按升序放置。

为了做到这一点，我们首先需要理解它的工作逻辑。让我们举个例子来解释一下。

我们初始化`a`数组并在其中声明值，如下面的代码所示：

```java
int a[]= {2,6,1,4,9};
```

我们可以使用冒泡排序机制来比较变量，并将它们按照我们想要的顺序放置。对于上面的例子，逻辑的工作方式如下；我们将`2`与`6`、`2`与`1`、`2`与`4`和`2`与`9`进行比较。在这次比较后，最小的数字是`1`，我们将其位置与第一个索引交换，即`2`。因此交换后，`1`将成为新的第一个索引。这意味着`1`是数组中给定值中最小的数字。现在我们移动到第二个索引，我们不会触及第一个索引，因为我们已经比较并声明`1`为固定的第一个索引，因为它是数组中最小的数字。现在我们取值`6`，它是第二个索引，并将其与数组中的其他值进行比较。首先我们比较`6`和`2`，由于`2`小于`6`，我们交换它们的位置，所以`2`是新的第一个索引，`6`是第二个索引。然后我们比较`2`和`3`；基本上我们是将第一个索引与数组中的所有其他值进行比较。然后我们将`2`与`3`、`2`与`4`和`2`与`9`进行比较；这里`2`是最小的数字。所以`2`成为数组中固定的第二个索引。现在我们还剩下四个需要排序的值。我们再次将`6`与其他值进行比较。`6`小于`3`，所以我们交换`6`和`3`的位置。这使得`3`成为数组中的第三个索引，我们将`3`与其他数字进行比较，`3`是其中最小的。所以`3`成为数组中固定的第三个索引。然后我们对最后三个值执行相同的操作，并得出最终的排列将是`1`、`2`、`3`、`4`、`6`、`9`。现在我们需要在 Java 程序中应用这个逻辑并打印它。

我们将为我们的逻辑决定一个算法，并根据算法逐步设计我们的代码。我们将编写一个外部的`for`循环，移动一个索引并与其余部分进行比较。

我们编写一个外部的`for`循环，并设置条件不要越过数组的长度；这里数组大小为`5`，所以条件设置为`i`小于`5`。如果`i`为`0`，变量值将与第一、第二、第三和第四个变量进行比较。如果`i`为`2`，变量将与第三和第四个变量进行比较。所以无论`i`索引是什么，它都应该开始比较`i`的值与其下一个索引的值。为此，我们将创建一个内部的`for`循环，并将`j`初始化为始终比`i`多一个数字，即`i`加`1`，因为我们将与下一个索引进行比较。所以，如果`i`等于`0`，`j`将为`1`。因此，零索引将从第一个索引开始比较。我们将比较直到数组的末尾，所以我们将内部的`for`循环的限制设置为`j`，因为它小于数组的长度，在这个例子中为`5`。

然后我们在内部的`for`循环中添加一个`if`循环。这个循环将在索引之间进行比较，并在满足条件时交换值。一旦第一轮比较完成，控制器退出内部的`for`循环，回到外部的`for`循环，这时进行比较后选择最小的数字，将其推到角落，并且索引移动到下一个值。

现在我们回到`if`循环内部，并编写代码在比较条件为真时交换值。为了交换变量的值，我们需要声明一个`temp`变量，并将`a[i]`的数字赋值给`temp`。我们添加以下代码成功交换变量：

```java
temp=a[i];
 a[i]=a[j];
 a[j]=temp;
```

最后，我们添加一个打印语句，显示经过比较和重新排列值后的最终数组。

最终输出将显示如下：

```java
1
2
4
6
9
```

# 总结

在本章中，我们涵盖了数组中的各种概念。我们看了不同类型的数组，以及它们如何被初始化和显示。然后我们进行了不同的练习，以了解我们如何在不同情况下使用数组。

在下一章中，我们将讨论为什么`Date`类和构造函数是 Java 的重要部分。
